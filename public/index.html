<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>neopkm</title>
    <script src="js/d3.v6.min.js"></script>
    <script src="js/neo4j-driver"></script>
    <script src="js/split.min.js"></script>
    <script src="https://www.youtube.com/iframe_api"></script>
    
    
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            /*background-color: #121212;*/
	    background-color #000;
            color: #e0e0e0;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
        }

/* Thin dark scrollbars */
::-webkit-scrollbar {
  width: 8px; /* Change this to make the scrollbar thicker or thinner */
  height: 8px; /* Change this to make the scrollbar thicker or thinner */
}

::-webkit-scrollbar-track {
    background: #000; /*#1e1e1e;*/
}

::-webkit-scrollbar-thumb {
  background-color: #cc0000 /*#888;*/ /* Change this to your preferred scrollbar color */
  border-radius: 10px;
  border: 2px solid #000; /*#1e1e1e;*/
}

::-webkit-scrollbar-thumb:hover {
    background: #ff0000;/*#555;*/
}

        svg {
            width: 100%;
            height: 100%;
            /*background-color: #1e1e1e;*/
	    background-color: #000;
            cursor: grab;
            border-bottom: 1px solid #333;
        }
    .emoji {
	width: 1em;
	height: 1em;
	vertical-align: middle;  /* Aligns emoji with text */
    }
        #inspector {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 250px;
            background: #000; /*#1e1e1e;*/
            border: 1px solid #000; /*1px solid #333;*/
            padding: 15px;
            display: none;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            overflow: auto;
        }
        #inspector h3 {
            margin-top: 0;
            font-size: 18px;
            color: #f0f0f0;
        }
        #inspector label {
            display: block;
            margin-bottom: 10px;
            font-size: 14px;
            color: #ccc;
        }
        #inspector input {
            width: 100%;
            margin-bottom: 10px;
            padding: 5px;
            background: #000; /*#333;*/
            border: 1px solid #555;
            color: #e0e0e0;
            border-radius: 4px;
        }
        #connections {
            margin-top: 10px;
        }
        #connections h4 {
            font-size: 16px;
            color: #f0f0f0;
            margin-top: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        #connections h4 button {
            background: none;
            border: none;
            color: #f0f0f0;
            font-size: 18px;
            cursor: pointer;
        }
        #connections ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        #connections ul li {
            font-size: 14px;
            color: #ccc;
            cursor: pointer;
            padding: 10px;
            border-bottom: 1px solid #333;
            margin-bottom: 5px;
            border-radius: 4px;
        }
        #connections ul li:hover {
            color: #fff;
            background-color: #333;
        }
        .title-bar {
            background-color: #000; /*#333;*/
            color: #ccc;
            display: flex;
            align-items: center;
            /*justify-content: space-between;*/
            padding: 10px;
            cursor: ns-resize;
            position: sticky;
            top: 0;
            width: 100%;
            z-index: 10;
        }
        .title-bar button {
            background: none;
            border: none;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 1.2em;
            margin-right: 10px;
            opacity: 1;
	    filter: none;
            transition: opacity 0.3s, filter 0.3s;
	    
        }
    .title-bar button.hidden {
	opacity: 0.5;
	/*filter: grayscale(100%);*/
    }

     
        #split-container {
            background-color: #f0f0f0;
            position: absolute;
            top: 50px; /* Initial top position */
            bottom: 0;
            width: 100%;
            /*(transition: top 0.2s;*/
        }
        .flex-container-vertical {
            display: flex;
            flex-direction: column;
            /*height: calc(100% - 50px); */ /* Adjust the height considering the title bar */
            width: 100%;
            position: relative;
            overflow: hidden;
        }
        .flex-container {
            display: flex;
            flex: 1;
            width: 100%;
            position: relative;
            overflow: hidden;
        }
        .section {
            /*display: none;*/
            flex-direction: column;
            border: 1px solid #444;
            overflow: hidden;
            background-color: #1e1e1e;
        }
        textarea {
            flex: 1;
            resize: none;
            padding: 10px;
            background-color: #1e1e1e;
            color: #e0e0e0;
            border: none;
	    text-decoration: none !important;

        }
#horizontal-splitter {
    background-color: #333;
}
iframe, webview {
            //flex: 1;
            border: none;
	    //display: none;
        }

        #code-editor textarea {
            width: 100%;
            height: 100%;
            background: #121212;
            color: #e0e0e0;
            border: none;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
	    text-decoration: none !important;

        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #555;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #333;
        }
        td[contenteditable="true"] {
            background-color: #222;
        }
        pre {
            background-color: #333;
            padding: 10px;
            overflow: auto;
        }
        .delete-btn {
            cursor: pointer;
            color: red;
            font-size: 1.2em;
        }
        .grid-line {
            stroke: #333;
        }
        #spotlightSearch {
            display: none;
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: #1e1e1e;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            width: 400px;
            padding: 20px;
            z-index: 10000;
        }
        #searchTitle {
            margin-bottom: 10px;
            font-size: 18px;
        }
        #searchInput {
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            font-size: 16px;
            background-color: #2e2e2e;
            color: #ffffff;
            border: 1px solid #444444;
        }
        #results {
            margin-top: 10px;
        }
        .result-item {
            padding: 10px;
            border-bottom: 1px solid #444444;
            cursor: pointer;
            background-color: #2e2e2e;
            color: #ffffff;
        }
        .result-item:hover, .result-item.selected {
            background-color: #444444;
        }
        .grouping-box {
            fill: purple;
            fill-opacity: 0.3;
            stroke: purple;
            stroke-width: 1px;
            stroke-dasharray: 4;
        }
        .resize-handle {
            fill: white;
            stroke: purple;
            stroke-width: 1px;
            cursor: nwse-resize;
        }
        .selected {
            stroke: red;
        }

.gutter {
    background-color: #333;
    background-repeat: no-repeat;
    background-position: 50%;
}

.gutter.gutter-horizontal {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==');
    cursor: col-resize;
}

  .highlight {
            stroke: white;
            stroke-width: 1.5px;
  }

     .red-filter {
        position: relative;
	z-index:6666;
        }

        .red-filter::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: red;
            mix-blend-mode: multiply;
        pointer-events: none;
	filter: brightness(50%);
	background-color #000;
	
        }
    .invert-filter {
      filter: invert(1);
    }

    .overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.01); /* Transparent */
        display: none;
    }
    .overlay.active {
        display: block;
    }
    #video-container {
	/*flex-direction: row;*/
    }

    #web-container {
	flex-direction: row;
    }



/* Base tab styling */
.tab-button {
    background-color: #000;  /* Darker background for dark mode */
    color: #b3b3b3;  /* Softer light text for better readability */
    border-radius: 12px;  /* Slightly smaller rounded corners */
    font-size: 10px;  /* Smaller font size */
    width: 140px;  /* Slightly narrower for a sleeker look */
    /*padding: 6px 12px;*/  /* Adjusted padding for better text fit */
    border: 0px solid #555;  /* Subtle contrast for the border */
    margin-right: 6px;  /* Reduced space between tabs */
    cursor: pointer;
    text-align: center;  /* Center the text */
    overflow: hidden;  /* Prevent text overflow */
    text-overflow: ellipsis;  /* Add ellipsis if text is too long */
    white-space: nowrap;  /* Keep the text on a single line */
    transition: background-color 0.2s ease, color 0.2s ease;
}

/* Hover effect */
.tab-button:hover {
    background-color: #3a3a3a;  /* Slightly lighter on hover */
    color: #e0e0e0;  /* Brighter text on hover */
}

/* Active tab styling */
.tab-button.active {
    background-color: #222;  /* Slightly lighter for active tab */
    color: #f0f0f0;  /* Brighter text for active tab */
    /*border: 1px solid #4a4a4a;*/
}

/* Flash effect */
.flash {
    animation: flash 1s;
}

@keyframes flash {
    0% { background-color: #4a4a4a; }
    50% { background-color: #5a5a5a; }
    100% { background-color: #4a4a4a; }
}

/* Optional: to handle overflow, you can add this */
#tabs {
    overflow-x: auto;
    white-space: nowrap;
}








</style>

    <link rel="stylesheet" href="youtube_search_modal.css">
    <link rel="stylesheet" href="MarginaliaSearchModal_styles.css">
    

</head>
    <body>
    
    <svg id="nodeWorldSVG">
        <defs>
            <marker id="arrowhead" viewBox="0 -5 10 10" refX="10" refY="0" markerWidth="6" markerHeight="6" orient="auto">
                <path d="M0,-5L10,0L0,5" fill="#999" />
            </marker>
        </defs>
    </svg>
    <div id="inspector">
    <div id="propertyDiv">
    </div>


    <div id="connections">
            <h4>
                Connections To
                <button id="linkConnectionsToButton">üîó</button>
            </h4>
            <ul id="connectionsToList"></ul>
            <h4>
                Connections From
                <button id="linkConnectionsFromButton">üîó</button>
            </h4>
            <ul id="connectionsFromList"></ul>
            <h4>Other Instances</h4>
            <ul id="siblingsList"></ul>
        </div>
    </div>
    <div class="flex-container-vertical" id="split-container">
    <div class="title-bar" id="title-bar">
    <div></div>
    <button onclick="toggleSection('code-editor')" class="hidden">
<img src="images/code-icon.svg" alt="code editor" class="emoji">
    </button>
    <button onclick="toggleSection('flake-editor')" class="hidden">
     <img src="images/nix-logo.svg" alt="flake" class="emoji">
    </button>
    <button onclick="toggleSection('test-editor')" class="hidden">
    <img src="images/tests-icon.svg" alt="tests pane" class="emoji">
</button>
    
    <button onclick="toggleSection('console-container')" class="hidden">
    <img src="images/console-icon.svg" alt="console viewer" class="emoji">
    
    </button>
    <button onclick="runCommand()" class="hidden">
    <img src="images/run-icon.svg" alt="upload script" class="emoji">
</button>
    
    <button onclick="toggleSection('video-container')" class="hidden">
    <img src="images/video-icon.svg" alt="video viewer" class="emoji">
    </button>
    <button onclick="toggleSection('web-container')" class="hidden">
    üåê
    </button>
    <button id="toggle-filter" class="hidden" onclick="setupRedMode();">üåª</button>

    <button id="toggle-filter" class="hidden" onclick="document.getElementById('video-container').classList.toggle('invert-filter');document.getElementById('web-container').classList.toggle('invert-filter');  ">invert</button>

  <input type="file" id="imageInput">
  <button id="screenshot-button" onclick="uploadImage()">üì∑</button>
  <div id="uploadStatus"></div>
            <!--<button onclick="toggleSplitContainer()" id="toggleButton" style="background-color: #333; border: none; color: #ccc; width: 30px; height: 30px; border-radius: 5px; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-right: 15px; transform: scaleX(1.1) scaleY(0.7) translateY(0.3em)">
                ^
    </button>-->
  <div id="tabs" style="width:100%, height:100%">
    <!-- tabs go here -->
  </div>
  <div></div>
    </div>
    <div id="horizontal-splitter" class="flex-container">
      <div class="overlay"></div>    <!-- this way we can drag over iframes without problems -->
      <div id="code-editor" class="section">
        <textarea id="nodeCode"></textarea>
      </div>
      <div id="flake-editor" class="section">
        <textarea id="nodeFlake"></textarea>
      </div>
      <div id="test-editor" class="section">
        <table id="nodeTestsTable">
          <thead>
            <tr>
              <th>Input</th>
              <th>Output</th>
              <td class="run-tests" onclick="runTests(this)">üèÉ‚Äç‚ôÄÔ∏è</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td contenteditable="true"></td>
              <td contenteditable="true"></td>
              <td class="delete-btn" onclick="deleteRow(this)">‚ùå</td>
            </tr>
          </tbody>
        </table>
      </div>
      <div id="console-container" class="section">
        <webview id="consoleContainer" src="" allowfullscreen></webview>
      </div>
      
      <div id="video-container" class="section">
	
	<div id="player"></div>
      </div>
      
    </div>
    </div>
    <div id="spotlightSearch">
      <div id="searchTitle"></div>
      <input type="text" id="searchInput" placeholder="Search...">
      <div id="results"></div>
    </div>
    
    <!-- youtube popup modal on ctrl+shift+y -->
        <div id="YoutubeSearchModal_videoModal" class="YoutubeSearchModal_modal">
        <div class="YoutubeSearchModal_modal-content">
            <span class="YoutubeSearchModal_close">&times;</span>
            <input type="text" id="YoutubeSearchModal_apiKeyInput" class="YoutubeSearchModal_input" placeholder="Enter YouTube API Key">
            <div id="YoutubeSearchModal_apiKeyError" class="YoutubeSearchModal_error"></div>
            <input type="text" id="YoutubeSearchModal_searchInput" class="YoutubeSearchModal_input" placeholder="Search for videos...">
            <button id="YoutubeSearchModal_searchButton" class="YoutubeSearchModal_button">Search</button>
            <div id="YoutubeSearchModal_videoResults"></div>
        </div>
    </div>

    <!-- Marginalia Modal ctrl+shift+m -->
        <div id="MarginaliaSearchModal" class="MarginaliaSearchModal_modal">
        <div class="MarginaliaSearchModal_modal-content">
            <span class="MarginaliaSearchModal_close">&times;</span>
            <input type="text" id="MarginaliaSearchModal_searchInput" placeholder="Search Marginalia...">
            <button id="MarginaliaSearchModal_searchButton">Search</button>
            <div id="MarginaliaSearchModal_results"></div>
        </div>
    </div>
    
    
        
    <script src="youtube_search_modal.js"></script>
    <script src="MarginaliaSearchModal_script.js"></script>

    <!-- setup red mode-->
    <script>
      function setupRedMode() {
	  document.body.classList.toggle('red-filter');
	  document.getElementById('inspector').classList.toggle('red-filter');
	  document.getElementById('horizontal-splitter').classList.toggle('red-filter');
	  document.getElementById('spotlightSearch').classList.toggle('red-filter');
	  document.getElementById('title-bar').classList.toggle('red-filter');
	  document.querySelectorAll('.title-bar button').forEach(button => button.classList.toggle('red-filter'));
      }
      </script>
    
    <!-- neopkm_config node for saving various states of UI elements -->
    <script>
      async function updateConfigNodeProperty(property, value) {

	const session = driver.session();
	
	try {
            const result = await session.run(
		`
            MATCH (n { label: ".neopkm_config" })
            SET n.\`${property}\` = $value
            RETURN n
            `,
		{ value }
            );
	    
            // Check if a node was returned
            if (result.records.length > 0) {
		console.log("Node updated:", result.records[0].get('n').properties);
            } else {
		console.log("No node found with label '.neopkm_config'");
            }
	} catch (error) {
            console.error("Error updating node:", error);
	} finally {
            // Close the session
            await session.close();
	}
    }




async function getNodeProperties() {
    const session = driver.session();
    try {
        const result = await session.run(
            `
            MATCH (n { label: ".neopkm_config" })
            RETURN n
            `
        );

        // Check if a node was found and returned
        if (result.records.length > 0) {
            const node = result.records[0].get('n');
            console.log("Node properties:", node.properties);
            return node.properties;
        } else {
            console.log("No node found with label '.neopkm_config'");
            return null;
        }
    } catch (error) {
        console.error("Error retrieving node properties:", error);
    } finally {
        // Close the session
        await session.close();
    }
}






async function loadUIStateFromConfigNode() {
    
    // finds all the node properties and sets them up
    getNodeProperties().then((properties) => {
	if (properties) {
            // Do something with the properties, if needed
	    console.log(properties);
	    
	    const titleBar = document.getElementById('title-bar');

	    setTitleBarPosition(titleBar,properties.titlebar_position)
	    
	    processSectionsJSON(properties.sectionState);
	    
	}
	
    });
    
    
    
    }

</script>
    
    <!-- webview and tabs -->
    <script>




window.DarkReader = require('darkreader');
      function createWebView(title, src, initialize=false, display="flex") {
    // Check if a tab with the same src already exists                                                                                                                                                             
    const tabs = document.getElementById('tabs');                                                                                                                                                                  
    const existingTabButton = Array.from(tabs.children).find(button => button.dataset.src === src);                                                                                                                
                                                                                                                                                                                                                   
    if (existingTabButton) {                                                                                                                                                                                       
        // Flash the existing tab button                                                                                                                                                                           
        existingTabButton.classList.add('flash');                                                                                                                                                                  
        setTimeout(() => {                                                                                                                                                                                         
            existingTabButton.classList.remove('flash');                                                                                                                                                           
        }, 1000);                                                                                                                                                                                                  
                                                                                                                                                                                                                   
        return;                                                                                                                                                                                                    
    }                                                                                                                                                                                                              
                                                                                                                                                                                                                   
    // Create a new webview element                                                                                                                                                                                
    const webview = document.createElement('webview');                                                                                                                                                             
    webview.src = src;                                                                                                                                                                                             
    webview.className = 'section';                                                                                                                                                                                 
	  webview.style.display = display;
          
	  webview.setAttribute("preload", "preload.js");
	  
	  webview.setAttribute('nodeintegration', '');
	  webview.setAttribute('nodeintegrationinsubframes', '');
	  webview.setAttribute('tabname', title)                                                                                                               
          
	  // Create a unique id for the webview                                                                                                                                                                          
    const webviewId = `webview-${Date.now()}`;                                                                                                                                                                     
    webview.id = webviewId;                                                                                                                                                                                        
                                                                                                                                                                                                                   
    // Append the webview to the video-container                                                                                                                                                                   
    const container = document.getElementById('horizontal-splitter');                                                                                                                                              
    container.appendChild(webview);                                                                                                                                                                                
                                                                                                                                                                                                                   
    // Create the tab button                                                                                                                                                                                       
    const tabButton = document.createElement('button');                                                                                                                                                            
    tabButton.className = 'tab-button';                                                                                                                                                                            
    tabButton.dataset.src = src; // Store the src in the button's dataset for easy lookup                                                                                                                          
                                                                                                                                                                                                                   
    // Set the favicon as the button's background image                                                                                                                                                            
    const faviconUrl = `https://www.google.com/s2/favicons?domain=${new URL(src).hostname}`;                                                                                                                       
    const hostname = new URL(src).hostname;                                                                                                                                                                        
    tabButton.style.backgroundImage = `url(${faviconUrl})`;                                                                                                                                                        
    tabButton.style.backgroundSize = '16px 16px';                                                                                                                                                                  
    tabButton.style.backgroundRepeat = 'no-repeat';                                                                                                                                                                
    tabButton.style.paddingLeft = '20px'; // Adjust padding for label                                                                                                                                              
                                                                                                                                                                                                                   
    // Apply tab styling                                                                                                                                                                                           
    tabButton.style.display = 'inline-block';                                                                                                                                                                      
    //tabButton.style.padding = '10px';                                                                                                                                                                              
    //tabButton.style.border = '1px solid #111';                                                                                                                                                                     
	  //tabButton.style.borderBottom = 'none';


	  if (display === "flex") {
	      tabButton.style.backgroundColor = '#222';
	  } else {
	      tabButton.style.backgroundColor = '#000';
	  }
	
	  tabButton.style.cursor = 'pointer';                                                                                                                                                                            
                                                                                                                                                                                                                   
    // Fetch the title from the webview                                                                                                                                                                            
    /*webview.addEventListener('did-finish-load', () => {                                                                                                                                                            
        webview.executeJavaScript('document.title').then(title => {                                                                                                                                                
            tabButton.textContent = title || hostname;                                                                                                                                                             
        }).catch(() => {                                                                                                                                                                                           
            tabButton.textContent = hostname;                                                                                                                                                                      
        });                                                                                                                                                                                                        
	});*/
    tabButton.textContent = title;
                                                                                                                                                                                                                   
    // Toggle visibility of the corresponding webview on click                                                                                                                                                     
    tabButton.addEventListener('click', () => {                                                                                                                                                                    
        if (webview.style.display === 'none') {                                                                                                                                                                    
        webview.style.display = 'flex';
	
	//tabButton.style.border = '1px solid #111';                                                                  
        tabButton.style.backgroundColor = '#222'; // Active tab color                                                                                                                                          
        } else {                                                                                                                                                                                                   
            webview.style.display = 'none';
            tabButton.style.backgroundColor = '#000'; // Inactive tab color                                                                         
	tabButton.style.border = '1px solid #000';                                                                                                                                 
        }

        initializeSplit();

	updateConfigNodeProperty("sectionState",getSectionsState())

    });                                                                                                                                                                                                            
                                                                                                                                                                                                                   
    // Delete the webview and button on right-click                                                                                                                                                                
    tabButton.addEventListener('contextmenu', (event) => {                                                                                                                                                         
        event.preventDefault();                                                                                                                                                                                    
        container.removeChild(webview);                                                                                                                                                                            
        tabButton.parentNode.removeChild(tabButton);

	initializeSplit();

	updateConfigNodeProperty("sectionState",getSectionsState())

    });

    // any time a section is opened
    initializeSplit();
    if (!initialize) {

	updateConfigNodeProperty("sectionState",getSectionsState())
    }

     
                                                                                                                                                                                                                   
    // Append the button to the tabs div                                                                                                                                                                           
    tabs.appendChild(tabButton);                                                                                                                                                                      
}              



</script>


    <!-- drag and drop new node -->
<script>
    // script.js

document.addEventListener('DOMContentLoaded', () => {
    const dropZone = d3.select('svg');
    let linkProcessed = false; // Flag to ensure only one link is processed

    dropZone.on('dragover', (event) => {
        event.preventDefault();
        dropZone.select('rect').style('stroke', '#000');
    });

    dropZone.on('dragleave', (event) => {
        dropZone.select('rect').style('stroke', '#ccc');
    });

    dropZone.on('drop', (event) => {
        event.preventDefault();
        dropZone.select('rect').style('stroke', '#ccc');
        linkProcessed = false; // Reset flag on each drop event

        const dataTransfer = event.dataTransfer;

        if (dataTransfer.items) {
            // Use DataTransferItemList interface to access the file(s)
            [...dataTransfer.items].forEach((item) => {
		                if (item.type === "text/html" && !linkProcessed) {
                    item.getAsString((htmlString) => {


                        // Parse the HTML string
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(htmlString, 'text/html');

                        // Find the first <a> element and get its href attribute
                        const linkElement = doc.querySelector('a');
                        if (linkElement) {
                            const link = linkElement.href;
                            handleLinkDrop(linkElement.title || linkElement.alt, link);
                        }

                        // Find the first element with a src attribute and get its src value
                        const srcElement = doc.querySelector('[src]');
                        if (srcElement) {
                            const src = srcElement.src;
                            console.log('Src attribute:', srcElement);
			    handleLinkDrop(srcElement.title || srcElement.alt, src);
                            // You can handle the src attribute here if needed
                        }

                        linkProcessed = true; // Set flag to true after processing link
                    });
                } else if (item.kind === 'file') {
                    const file = item.getAsFile();
                    handleFileDrop(file);
                }

		
            });
        } else {
            // Use DataTransfer interface to access the file(s)
            [...dataTransfer.files].forEach((file) => {
                handleFileDrop(file);
            });
        }
    });
});



function handleFileDrop(file) {
    const formData = new FormData();
    formData.append('image', file);

    fetch('/upload', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            document.getElementById('uploadStatus').innerHTML = `Upload successful! File path: ${data.filename}`;
            createNodeAndLink(currentNode.id, currentNode.x_positions[0], currentNode.y_positions[0] + 30,
                              data.filename, "", "uploads/" + data.filename);
        } else {
            document.getElementById('uploadStatus').innerHTML = 'Upload failed!';
        }
    })
    .catch(error => {
        document.getElementById('uploadStatus').innerHTML = 'Error occurred during upload!';
        console.error('Error:', error);
    });
}

function handleLinkDrop(title, link) {                                                                                                                                                                              
    // If title is undefined, use link as the title
    if (typeof title === 'undefined' || title === null || title === '') {
        title = link;
    }

    console.log('Link dropped:', title, link);                                                                                                                                                                     
    //createNodeAndLink(sourceId, x, y, label, url, imageUrl)                                                                                                                                                     
    createNodeAndLink(currentNode.id, currentNode.x_positions[0], currentNode.y_positions[0] + 30,                                                                                                                   
                      title, link, "")                                                                                                                                                                                   .then(function(node) {
			  console.log('createNodeAndLink return value:', node);
			  //svg.transition().call(zoom.translateTo, node.x_positions[node.instance], node.y_positions[node.instance]);
			  //selectNode(null, node)

	
        })
        .catch(function(error) {
            console.error('Error creating node and link:', error);
        });
} 


</script>


    <!-- image upload -->
      <script>
    function uploadImage() {
      const imageInput = document.getElementById('imageInput');
      const file = imageInput.files[0];
      const formData = new FormData();
      formData.append('image', file);

      fetch('/upload', {
        method: 'POST',
        body: formData
      })
      .then(response => response.json())
      .then(data => {
        if (data.status === 'success') {
            document.getElementById('uploadStatus').innerHTML = `Upload successful! File path: ${data.filename}`;
	    createNodeAndLink(currentNode.id, currentNode.x_positions[0], currentNode.y_positions[0]+30,
			      data.filename, "", "uploads/"+data.filename);
        } else {
          document.getElementById('uploadStatus').innerHTML = 'Upload failed!';
        }

	  
      })
      .catch(error => {
        document.getElementById('uploadStatus').innerHTML = 'Error occurred during upload!';
        console.error('Error:', error);
      });
    }
      </script>
      

    <!-- managing youtube video position -->
    <script>



  // Load the IFrame Player API code asynchronously.
    var tag = document.createElement('script');
    tag.src = "/proxy?url=https://www.youtube.com/iframe_api";
    var firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    // Create a variable to hold the playah
    var player;
    var videoIdToLoad = null;
      var startTime = 0;
var lastVideoId = "";
var lastVideoNodeId = "";

    // This function creates an <iframe> (and YouTube player) after the API code downloads.
    function onYouTubeIframeAPIReady() {
      if (videoIdToLoad) {
        createPlayer(videoIdToLoad, startTime);
      }
    }

    // Function to create the YouTube player
      function createPlayer(videoId, startTime) {
      player = new YT.Player('player', {
        height: '100%',
        width: '100%',
        videoId: videoId,
        events: {
          'onReady': function(event) { onPlayerReady(event, startTime); },
          'onStateChange': onPlayerStateChange
        }
      });
    }

    // Function to set up the YouTube player with the given video ID and start time
      function setupYouTubePlayer(videoId, time = 0) {
	  if (videoId === lastVideoId) {
	      console.log("this video already got a playah in the game!")
	      return;
	  }
	  lastVideoId = videoId;
	  lastVideoNodeId = currentNode.id;

	  console.log(document.getElementById('player'))
	  //document.getElementById('webviewElement').style.display = "none";
	  document.getElementById('player').style.display = "flex";
	  
	startTime = parseFloat(time);
      if (typeof YT !== 'undefined' && YT && YT.Player) {
        if (player) {
          player.loadVideoById(videoId);
          startTime = time;
        } else {
          createPlayer(videoId, startTime);
        }
      } else {
        videoIdToLoad = videoId;
        startTime = time;
      }
    }

    // The API will call this function when the video player is ready.
    function onPlayerReady(event, startTime) {
      // Nothing to do here anymore
    }

    // The API calls this function when the player's state changes.
    function onPlayerStateChange(event) {
	if (event.data == YT.PlayerState.PLAYING && startTime > 0) {
            player.seekTo(startTime, true);
	    console.log(startTime)
            startTime = 0; // Reset start time to prevent seeking multiple times
	}

	if (player) {
	var currentTime = player.getCurrentTime();
	    console.log('Current time: ' + currentTime + ' seconds');
	    if (currentTime > 5) {
		updateNodeProperty(lastVideoNodeId, "videoTime", currentTime)
	    }
	
	}


      if (event.data == YT.PlayerState.ENDED) {
        console.log('Video has ended');
      }
    }






    </script>

    <!-- saving scroll position on the iframe -->
    <script>

// TODO Fix scroll position

    let currentNode;

async function updateNodeProperty(nodeId, propertyName, propertyValue) {
  const session = driver.session();
  
  try {
    // Construct the query dynamically using the propertyName
    const query = `MATCH (n { id: $nodeId }) SET n.${propertyName} = $propertyValue RETURN n`;
    
    // Run the query to set the specified property
    const result = await session.run(
      query,
      { nodeId: nodeId, propertyValue: propertyValue }
    );

      console.log(`${nodeId}'s property ${propertyName} updated to ${propertyValue}`, result);
  } catch (error) {
    console.error('Error updating node:', error);
  } finally {
    await session.close();
  }
}
/*
// Function to save scroll position in an Electron webview
function saveScrollPosition() {
    console.log("SAVING SCROLL POSITION");

    const webview = document.getElementById('webviewElement'); // Get the webview element
    webview.executeJavaScript(`
        const scrollPosition = document.documentElement.scrollTop || document.body.scrollTop;
        scrollPosition;
    `).then(scrollPosition => {
        updateNodeProperty(currentNode.id, "scrollPosition", scrollPosition);
        // localStorage.setItem(currentNode.id + 'webviewScrollPosition', scrollPosition);
    }).catch(err => {
        console.error("Error getting scroll position: ", err);
    });
}


// Function to restore scroll position in an Electron webview
function restoreScrollPosition(currentNode) {
    const scrollPosition = currentNode.scrollPosition; // or localStorage.getItem(currentNode.id + 'webviewScrollPosition');
    console.log("RESTORING SCROLL POSITION", currentNode.scrollPosition);

    if (scrollPosition !== null) {
        const webview = document.getElementById('webviewElement'); // Get the webview element
        webview.addEventListener('dom-ready', () => {
            webview.executeJavaScript(`window.scrollTo(0, ${scrollPosition});`).catch(err => {
                console.error("Error restoring scroll position: ", err);
            });
        });
    }
}



    // Function to restore scroll position
function restoreScrollPosition(currentNode) {
    
    const scrollPosition = currentNode.scrollPosition; // localStorage.getItem(currentNode.id + 'iframeScrollPosition');
    console.log("RESTORING SCROLL POSITION",currentNode.scrollPosition)
      if (scrollPosition !== null) {
        const iframe = document.getElementById('webviewElement');
        iframe.contentWindow.scrollTo(0, scrollPosition);
      }
    }

// Add event listener to track scroll position in the webview
document.getElementById('webviewElement').addEventListener('dom-ready', function() {
    const webview = this;

    // Add a scroll event listener within the webview
    webview.executeJavaScript(`
        document.addEventListener('scroll', () => {
            clearTimeout(window.scrollTimeout);
            window.scrollTimeout = setTimeout(() => {
                const scrollPosition = document.documentElement.scrollTop || document.body.scrollTop;
                window.scrollPosition = scrollPosition;
                // Use a custom event to send scroll position back to the main page
                const event = new CustomEvent('save-scroll-position', { detail: scrollPosition });
                document.dispatchEvent(event);
            }, 100);
        });
    `);

    // Listen for the custom scroll position event from the webview
    webview.addEventListener('ipc-message', (event) => {
        if (event.channel === 'save-scroll-position') {
            const scrollPosition = event.args[0];
	    console.log("RECV SCROLL", scrollPosition)
            updateNodeProperty(currentNode.id, "scrollPosition", scrollPosition);
            // localStorage.setItem(currentNode.id + 'webviewScrollPosition', scrollPosition);
        }
    });

    // Restore scroll position when webview loads
    try {
        restoreScrollPosition(currentNode);
    } catch (error) {
        console.log(error);
    }
});
*/

    </script>

    <!-- managing the tests table -->

    <script>

            const table = document.getElementById('nodeTestsTable').getElementsByTagName('tbody')[0];

      function runTests(input) {
	  const code = `async function test(input) { \n ${document.getElementById('nodeCode').value} \n }`
	  const tests = JSON.parse(convertTableToJSONString())
	  console.log("code", code, "tests", tests)
	  evaluateJsonEntries(tests, code);
      }


async function evaluateJsonEntries(data, jsFunctionString) {
  // Convert the function string to an actual function
  const jsFunction = eval(`(${jsFunctionString})`);

  for (const [index, entry] of data.entries()) {
    if (entry.Input && entry.Output) {
      try {
        // Isolate the context to avoid redeclaration issues
        const input = eval(entry.Input.replace("input = ", ""));

        // Call the provided async function with the input and get the output
        const output = await jsFunction(input);

        // Evaluate the output condition
        const result = eval(entry.Output);

        console.log(`Entry ${index + 1}:`, result ? 'Passed' : 'Failed');
      } catch (error) {
        console.error(`Entry ${index + 1}: Error -`, error);
      }
    } else {
      console.log(`Entry ${index + 1}: Skipped (blank input/output)`);
    }
  }
	    }
	    

      
      
            
      function convertTableToJSONString() {
	  console.log("CONVERTING")
                const rows = table.getElementsByTagName('tr');
                const data = [];
                for (let i = 0; i < rows.length; i++) {
                    const cells = rows[i].getElementsByTagName('td');
                    const rowData = {};
                    rowData['Input'] = cells[0].innerText;
                    rowData['Output'] = cells[1].innerText;
                    data.push(rowData);
                }
		return JSON.stringify(data, null, 2);
            }

            table.addEventListener('input', function(event) {
                const cell = event.target;
                const row = cell.parentElement;
                const lastRow = table.rows[table.rows.length - 1];
                if (row === lastRow && cell === lastRow.cells[lastRow.cells.length - 2]) {
                    const newRow = table.insertRow();
                    for (let i = 0; i < lastRow.cells.length - 1; i++) {
                        const newCell = newRow.insertCell();
                        newCell.contentEditable = "true";
                    }
                    const deleteCell = newRow.insertCell();
                    deleteCell.className = "delete-btn";
                    deleteCell.innerHTML = "‚ùå";
                    deleteCell.onclick = function() { deleteRow(deleteCell); };
                }
                convertTableToJSONString();
            });

            window.deleteRow = function(button) {
                const row = button.parentElement;
                table.deleteRow(row.rowIndex - 1); // Adjust for zero-indexed
                convertTableToJSONString();
            };

	    function loadFromJSON(json) {
    // Check if json is null or undefined and set it to an empty array
    if (json === null || json === undefined) {
        json = '[{"Input":"", "Output":""}]';
    }
    
    //console.log("JSONNN", json);
    
    // Parse the JSON string safely
    let data;
    try {
        data = JSON.parse(json);
    } catch (e) {
        console.error("Invalid JSON:", e);
        return; // Exit the function if JSON is invalid
    }
    
    // Clear the existing table content
    table.innerHTML = '';
    
    // Populate the table with new data
    data.forEach(rowData => {
        const row = table.insertRow();
        for (const key in rowData) {
            if (rowData.hasOwnProperty(key)) {
                const cell = row.insertCell();
                cell.contentEditable = "true";
                cell.innerText = rowData[key];
            }
        }
        const deleteCell = row.insertCell();
        deleteCell.className = "delete-btn";
        deleteCell.innerHTML = "‚ùå";
        deleteCell.onclick = function() { deleteRow(deleteCell); };
    });
    // Convert table to JSON string if needed
    // convertTableToJSONString();
}

	    

            // Initial conversion to JSON on page load
            //convertTableToJSON();
      
    </script>
    
              
    <!-- split pane on the bottom -->
    <script>

const titleBar = document.getElementById('title-bar');
const splitContainer = document.getElementById('split-container');
const inspectorGadget = document.getElementById('inspector');
const nodeWorldSVG = document.getElementById('nodeWorldSVG');
let isDraggingTitleBar = false;
const overlay = document.querySelector('.overlay');
let newTop;

      function processSectionsJSON(jsonData) {
    // Parse the JSON data if it's in string form
    const sections = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;

    // Iterate over each section in the JSON
    sections.forEach(sectionData => {
        if (sectionData.src) {
            // If the section has a src, it's a webview
            const title = sectionData.tabname || 'Untitled';
            const src = sectionData.src;

            createWebView(title, src, initialize=true, display=sectionData.style.display || 'none');
        } else {
            // Otherwise, toggle the section based on its display property
            const id = sectionData.id;
            const display = sectionData.style.display || 'none';
            toggleSection(id, display, initialize=true);
        }
    });
}

      function getSectionsState() {
    // Get all section elements
    const sections = document.querySelectorAll('.section');

    // Create an array to store the section data
    const sectionsData = [];

    // Iterate over each section element
    sections.forEach(section => {
        // Get the id, style, and other attributes of the section
        const sectionData = {
            id: section.id || null,
            style: {
                display: section.style.display || null,
                width: section.style.width || null
            }
        };

        // If the section has a webview, include its src and tabName


        if (section.id.includes("webview")) {
	    // subtle, but the webview is NOT in a div, so we need the attributes from the section
            sectionData.src = section.src || null;
            sectionData.tabname = section.getAttribute('tabname') || null; // Ensure correct casing

        }

        // Add the section data to the array
        sectionsData.push(sectionData);
    });

    // Convert the sections data array to JSON
    const sectionsJSON = JSON.stringify(sectionsData, null, 2);

    return sectionsJSON;
}


      

function setTitleBarPosition(titleBar, pos) {
    splitContainer.style.top = `${pos}px`;
    inspectorGadget.style.maxHeight = `${pos-titleBar.offsetHeight-10}px`
    nodeWorldSVG.style.height = `${pos}px`;
}



titleBar.addEventListener('mousedown', function(e) {
    isDraggingTitleBar = true;
    overlay.classList.add('active');
    document.body.style.cursor = 'ns-resize';
});



inspectorGadget.style.maxHeight = `${window.innerHeight-titleBar.offsetHeight-10}px`
splitContainer.style.top = `${window.innerHeight-titleBar.offsetHeight}px`;

window.addEventListener('mousemove', function(e) {
    if (!isDraggingTitleBar) return;
    newTop  = e.clientY - titleBar.offsetHeight/2.0;
    
    if (newTop < 0) newTop = 0;
    if (newTop > window.innerHeight-titleBar.offsetHeight) newTop = window.innerHeight-titleBar.offsetHeight;
    //splitContainer.style.top = `${newTop}px`;
    //inspectorGadget.style.maxHeight = `${newTop-titleBar.offsetHeight-10}px`
    setTitleBarPosition(titleBar, newTop)
});



window.addEventListener('mouseup', function() {
    isDraggingTitleBar = false;
    overlay.classList.remove('active');
    
    document.body.style.cursor = 'default';
    
    updateConfigNodeProperty("titlebar_position", newTop)
});




function toggleSplitContainer() {
    var splitContainer = document.getElementById("split-container");
    var toggleButton = document.getElementById("toggleButton");
    
    if (splitContainer.style.display === "none") {
        splitContainer.style.display = "flex";
        toggleButton.innerHTML = "v";  // minus symbol
	toggleButton.style.transform = "scaleX(1.1) scaleY(0.6) translateY(-0.0em)";
    } else {
        splitContainer.style.display = "none";
        toggleButton.innerHTML = "^";  // caret symbol
	toggleButton.style.transform = "scaleX(1.1) scaleY(0.7) translateY(0.3em)";
    }
}


let splitInstance;

document.addEventListener('DOMContentLoaded', function() {
    initializeSplit();
    // this state should come from .neopkm_config
    //toggleSection('video-container', display="none")
});

function initializeSplit() {
    const sections = Array.from(document.querySelectorAll('.section')).filter(section => section.style.display !== 'none');
    if (splitInstance) {
        splitInstance.destroy();
    }
    if (sections.length > 0) {
        splitInstance = Split(sections.map(section => `#${section.id}`), {
            sizes: Array(sections.length).fill(100 / sections.length),
            minSize: 100,
            gutterSize: 5,
            cursor: 'col-resize',
        });
    }
    
}


	
      last_num = -1
      function toggleSection(id, display = 'toggle', initialize = false) {
	  const sections = Array.from(document.querySelectorAll('.section')).filter(section => section.style.display !== 'none');
	  //console.log(sections.length);

	  /* automatically closing split container
	  if (sections.length === 1 && last_num == 2) {
              document.getElementById("split-container").style.display = "none";
	  } else {
              document.getElementById("split-container").style.display = "flex";
	  }*/
	  
	  const section = document.getElementById(id);
	  const button = document.querySelector(`button[onclick="toggleSection('${id}')"]`);
	  
	  if (display === 'flex') {
              section.style.display = 'flex';
              button.classList.remove('hidden');
	  } else if (display === 'none') {
              section.style.display = 'none';
              button.classList.add('hidden');
	  } else {  // Toggle behavior
              if (section.style.display === 'none') {
		  section.style.display = 'flex';
		  button.classList.remove('hidden');
              } else {
		  section.style.display = 'none';
		  button.classList.add('hidden');
              }
    }
	  initializeSplit();

	  if(!initialize) {
	      updateConfigNodeProperty("sectionState",getSectionsState())
	  }




    last_num = sections.length
      }

      
            

			
		
    </script>

    <script>

	

        function setCodeEditorTitle(title) {
            //document.getElementById('title-bar').textContent = title;
        }

      /*
        function setVideoTitle(title) {
            document.getElementById('videoTitleBar').textContent = title;
        }
*/
function setVideoUrl(d) {
    const videoId = getYouTubeVideoId(d.url);
    if (videoId) {
	console.log("VIDEO NODE", parseFloat(d.videoTime))
	setupYouTubePlayer(videoId, time = parseFloat(d.videoTime));  // Replace this with the desired video ID
        const embedUrl = `https://www.youtube.com/embed/${videoId}`;
        //document.getElementById('webviewElement').src = `${embedUrl}`; //embedUrl
	
    } else {
	
        alert('Invalid YouTube URL');
    }
    const video = document.getElementById('video-container');
    video.style.display = 'flex';
    
}

function getYouTubeThumbnail(url) {
    const videoId = getYouTubeVideoId(url);
    if (videoId) {
	return `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
    }
    return null;
}

        function getYouTubeVideoId(url) {
            const urlObj = new URL(url);
            if (urlObj.hostname === 'www.youtube.com' || urlObj.hostname === 'youtube.com') {
                return urlObj.searchParams.get('v');
            } else if (urlObj.hostname === 'youtu.be') {
                return urlObj.pathname.substring(1);
            }
            return null;
        }

</script>





    <script>
const svg = d3.select("svg");
const g = svg.append("g");

const gridLayer = g.append("g").attr("class", "grid");

const groupingLayer = g.append("g").attr("class", "grouping-layer");

const linkLayer = g.append("g").attr("class", "links");
const inheritedLayer = g.append("g").attr("class", "inherited");
const nodeLayer = g.append("g").attr("class", "nodes");



// GROUPING LAYER
let isDragging = false;
let startPoint = null;
let currentBox = null;
let lastClickTime = 0;
const doubleClickThreshold = 300;
let lastSelectedNode = null;

svg.on("mousedown", (event) => {
    if (event.ctrlKey && event.target === svg.node()) {
        event.preventDefault();
        event.stopPropagation();
        isDragging = true;
        startPoint = d3.pointer(event, g.node());
        currentBox = groupingLayer.append("rect")
            .attr("class", "grouping-box")
            .attr("x", startPoint[0])
            .attr("y", startPoint[1])
            .attr("width", 0)
            .attr("height", 0);
    }
});

svg.on("mousemove", (event) => {
    if (isDragging && currentBox) {
        event.preventDefault();
        event.stopPropagation();
        const currentPoint = d3.pointer(event, g.node());
        const width = currentPoint[0] - startPoint[0];
        const height = currentPoint[1] - startPoint[1];
        currentBox
            .attr("width", Math.abs(width))
            .attr("height", Math.abs(height))
            .attr("x", width < 0 ? currentPoint[0] : startPoint[0])
            .attr("y", height < 0 ? currentPoint[1] : startPoint[1]);
    }
});

svg.on("mouseup", (event) => {
    if (isDragging) {
        event.preventDefault();
        event.stopPropagation();
        isDragging = false;
        if (currentBox) {
            const x = +currentBox.attr("x");
            const y = +currentBox.attr("y");
            const width = +currentBox.attr("width");
            const height = +currentBox.attr("height");
            createGroupingBoxNode(x, y, width, height);
            currentBox.remove();
            currentBox = null;
        }
    }
});

svg.on("mouseleave", (event) => {
    if (isDragging) {
        event.preventDefault();
        event.stopPropagation();
        isDragging = false;
        if (currentBox) {
            currentBox.remove(); // Remove incomplete box if mouse leaves the SVG
            currentBox = null;
        }
    }
});




// GROUPING LAYER


const gridSize = 50;

let nodes = []; // Declare nodes as a global variable
let links = []; // Declare links as a global variable

// Initialize Neo4j driver
const driver = neo4j.driver(
    'bolt://localhost:7687', // Replace with your Neo4j instance address
    neo4j.auth.basic('neo4j', 'password') // Replace with your Neo4j username and password
);

async function fetchFirstInstanceNodesAndLinks(x0, x1, y0, y1) {
    const session = driver.session();
    const result = await session.run(
        `MATCH (n)
         WHERE any(x IN n.x_positions WHERE x >= $x0 AND x <= $x1)
           AND any(y IN n.y_positions WHERE y >= $y0 AND y <= $y1)
         OPTIONAL MATCH (n)-[r]->(m)
         WHERE any(x IN m.x_positions WHERE x >= $x0 AND x <= $x1)
           AND any(y IN m.y_positions WHERE y >= $y0 AND y <= $y1)
         RETURN n, r, m,
                size((n)--()) AS n_connections,
                size((m)--()) AS m_connections`,
        { x0, x1, y0, y1 }
    );
    session.close();
    let nodes = []; // Reset nodes array
    let links = []; // Reset links array
    const nodeIds = new Set(); // Track unique node IDs

    result.records.forEach(record => {
        const nodeN = record.get('n').properties;
        nodeN.x_positions = nodeN.x_positions.map(Number); // Ensure x_positions are numbers
        nodeN.y_positions = nodeN.y_positions.map(Number); // Ensure y_positions are numbers
        nodeN.widths = nodeN.widths.map(Number); // Ensure widths are numbers
        nodeN.heights = nodeN.heights.map(Number); // Ensure heights are numbers
        nodeN.connections = record.get('n_connections'); // Add connections property

        // Only consider the first instance within the viewport
        const firstXIndex = nodeN.x_positions.findIndex(x => x >= x0 && x <= x1);
        const firstYIndex = nodeN.y_positions.findIndex(y => y >= y0 && y <= y1);
        if (firstXIndex !== -1 && firstYIndex !== -1 && firstXIndex === firstYIndex) {
            const nodeCopy = { ...nodeN, x: nodeN.x_positions[firstXIndex], y: nodeN.y_positions[firstYIndex], width: nodeN.widths[firstXIndex], height: nodeN.heights[firstXIndex], instance: firstXIndex };
            if (!nodeIds.has(nodeCopy.id)) { // Check for duplicate
                nodes.push(nodeCopy);
                nodeIds.add(nodeCopy.id); // Track node ID
            }
        }

        const nodeM = record.get('m') ? record.get('m').properties : null;
        if (nodeM) {
            nodeM.x_positions = nodeM.x_positions.map(Number); // Ensure x_positions are numbers
            nodeM.y_positions = nodeM.y_positions.map(Number); // Ensure y_positions are numbers
            nodeM.widths = nodeM.widths.map(Number); // Ensure widths are numbers
            nodeM.heights = nodeM.heights.map(Number); // Ensure heights are numbers
            nodeM.connections = record.get('m_connections'); // Add connections property

            // Only consider the first instance within the viewport
            const firstXIndexM = nodeM.x_positions.findIndex(x => x >= x0 && x <= x1);
            const firstYIndexM = nodeM.y_positions.findIndex(y => y >= y0 && y <= y1);
            if (firstXIndexM !== -1 && firstYIndexM !== -1 && firstXIndexM === firstYIndexM) {
                const nodeCopy = { ...nodeM, x: nodeM.x_positions[firstXIndexM], y: nodeM.y_positions[firstYIndexM], width: nodeM.widths[firstXIndexM], height: nodeM.heights[firstXIndexM], instance: firstXIndexM };
                if (!nodeIds.has(nodeCopy.id)) { // Check for duplicate
                    nodes.push(nodeCopy);
                    nodeIds.add(nodeCopy.id); // Track node ID
                }
            }
        }

        const relationship = record.get('r');
        if (relationship) {
            const source = nodeN.id;
            const target = nodeM ? nodeM.id : null;
            const type = relationship.type; // Get the relationship type
            if (target) {
                links.push({
                    source,
                    target,
                    type
                });
            }
        }
    });

    return { nodes, links };
}


async function fetchNodesAndLinks(x0, x1, y0, y1) {
    const session = driver.session();
    const result = await session.run(
        `MATCH (n)
         WHERE any(x IN n.x_positions WHERE x >= $x0 AND x <= $x1)
           AND any(y IN n.y_positions WHERE y >= $y0 AND y <= $y1)
         OPTIONAL MATCH (n)-[r]->(m)
         WHERE any(x IN m.x_positions WHERE x >= $x0 AND x <= $x1)
           AND any(y IN m.y_positions WHERE y >= $y0 AND y <= $y1)
         RETURN n, r, m,
                size((n)--()) AS n_connections,
                size((m)--()) AS m_connections`,
        { x0, x1, y0, y1 }
    );
    session.close();
    nodes = []; // Reset nodes array
    links = []; // Reset links array

    const nodesMap = new Map(); // Use a map to track nodes

    result.records.forEach(record => {
        const nodeN = record.get('n').properties;
        nodeN.x_positions = nodeN.x_positions.map(Number); // Ensure x_positions are numbers
	nodeN.y_positions = nodeN.y_positions.map(Number); // Ensure y_positions are numbers
	nodeN.widths = nodeN.widths.map(Number); // Ensure y_positions are numbers
	nodeN.heights = nodeN.heights.map(Number); // Ensure y_positions are numbers
        nodeN.connections = record.get('n_connections'); // Add connections property

        // Duplicate nodes for each position within the viewport
        nodeN.x_positions.forEach((x, index) => {
            if (x >= x0 && x <= x1 && nodeN.y_positions[index] >= y0 && nodeN.y_positions[index] <= y1) {
                const nodeCopy = { ...nodeN, x: x, y: nodeN.y_positions[index], width: nodeN.widths[index], height: nodeN.heights[index], instance: index };
                nodes.push(nodeCopy);
            }
        });

        const nodeM = record.get('m') ? record.get('m').properties : null;
        if (nodeM) {
            nodeM.x_positions = nodeM.x_positions.map(Number); // Ensure x_positions are numbers
            nodeM.y_positions = nodeM.y_positions.map(Number); // Ensure y_positions are numbers
	    nodeN.widths = nodeN.widths.map(Number); // Ensure y_positions are numbers
	    nodeN.heights = nodeN.heights.map(Number); // Ensure y_positions are numbers
            nodeM.connections = record.get('m_connections'); // Add connections property

            // Duplicate nodes for each position within the viewport
            nodeM.x_positions.forEach((x, index) => {
                if (x >= x0 && x <= x1 && nodeM.y_positions[index] >= y0 && nodeM.y_positions[index] <= y1) {
                    const nodeCopy = { ...nodeM, x: x, y: nodeM.y_positions[index], width: nodeN.widths[index], height: nodeN.heights[index], instance: index };
                    nodes.push(nodeCopy);
                }
            });
        }

        const relationship = record.get('r');
        if (relationship) {
            const source = nodeN.id;
            const target = nodeM ? nodeM.id : null;
            const type = relationship.type; // Get the relationship type
            if (target) {
                links.push({
                    source,
                    target,
                    type
                });
            }
        }
    });

    return { nodes, links };
}

async function fetchNodeById(nodeId) {
    const session = driver.session();
    const result = await session.run(
        `MATCH (n {id: $nodeId})
                 RETURN n`,
        { nodeId }
    );
    session.close();

    if (result.records.length === 0) {
        return null;
    }

    const node = result.records[0].get('n').properties;
    node.x = Number(node.x);
    node.y = Number(node.y);
    return node;
}

// SUPPORTING INHERITANCE
// Merge all inherited node into one node
// Separated Siblings
async function fetchNodeConnections(nodeId) {
    const session = driver.session();

    const getNodeConnections = async (nodeId) => {
        const resultTo = await session.run(
            `MATCH (n {id: $nodeId})-[r]->(m)
             WHERE NOT type(r) = 'INHERITED_FROM'
             RETURN m, size((m)--()) AS m_connections`,
            { nodeId }
        );
        const resultFrom = await session.run(
            `MATCH (n)<-[r]-(m)
             WHERE n.id = $nodeId AND NOT type(r) = 'INHERITED_FROM'
             RETURN m, size((m)--()) AS m_connections`,
            { nodeId }
        );

        const connectionsTo = [];
        const connectionsFrom = [];

        const processRecord = (record, connectionsArray) => {
            const node = record.get('m').properties;
            const xPositions = node.x_positions;
            const yPositions = node.y_positions;
            const widths = node.widths;
            const heights = node.heights;
            const connectionsCount = record.get('m_connections');

            if (Array.isArray(xPositions) && Array.isArray(yPositions) && xPositions.length === yPositions.length) {
                xPositions.forEach((x, index) => {
                    const y = yPositions[index];
                    connectionsArray.push({
                        ...node,
                        x: Number(x),
                        y: Number(y),
                        width: Number(widths[index]),
                        height: Number(heights[index]),
                        instance: index,
                        connections: connectionsCount
                    });
                });
            } else {
                // Handle the case where x_positions and y_positions arrays are missing or lengths do not match
                connectionsArray.push({
                    ...node,
                    x: null,
                    y: null,
                    width: null,
                    height: null,
                    instance: null,
                    connections: connectionsCount
                });
            }
        };

        resultTo.records.forEach(record => processRecord(record, connectionsTo));
        resultFrom.records.forEach(record => processRecord(record, connectionsFrom));

        return { connectionsTo, connectionsFrom };
    };

    const getInheritedNode = async (nodeId) => {
        const inheritedResult = await session.run(
            `MATCH (n {id: $nodeId})-[:INHERITED_FROM]->(m)
             RETURN m.id AS inheritedId, m`,
            { nodeId }
        );

        if (inheritedResult.records.length > 0) {
            const inheritedNode = inheritedResult.records[0].get('m').properties;
            const inheritedNodeId = inheritedResult.records[0].get('inheritedId');
            const inheritedConnections = await getNodeConnections(inheritedNodeId);

            return {
                ...inheritedNode,
                id: inheritedNodeId,
                inheritedConnections
            };
        }

        return null;
    };

    const getInheritors = async (nodeId) => {
        const inheritorsResult = await session.run(
            `MATCH (n)<-[:INHERITED_FROM]-(m)
             WHERE n.id = $nodeId
             RETURN m, size((m)--()) AS m_connections`,
            { nodeId }
        );

        const inheritors = [];
        inheritorsResult.records.forEach(record => {
            const inheritor = record.get('m').properties;
            const connectionsCount = record.get('m_connections');
            inheritors.push({
                ...inheritor,
                connections: connectionsCount
            });
        });

        return inheritors;
    };

    
    const getSiblings = async (nodeId, inheritedNodeId) => {
        const siblingsResult = await session.run(
            `MATCH (s)-[:INHERITED_FROM]->(m)
             WHERE m.id = $inheritedNodeId AND s.id <> $nodeId
             RETURN s, size((s)--()) AS s_connections`,
            { inheritedNodeId, nodeId }
            );

        const siblings = [];
        siblingsResult.records.forEach(record => {
            const sibling = record.get('s').properties;
            const connectionsCount = record.get('s_connections');
            siblings.push({
                ...sibling,
                connections: connectionsCount
            });
        });

        return siblings;
    };

    const mainConnections = await getNodeConnections(nodeId);
    const inheritedNode = await getInheritedNode(nodeId);
    const inheritors = await getInheritors(nodeId);

    let connectionsTo = mainConnections.connectionsTo;
    let connectionsFrom = mainConnections.connectionsFrom;
    let inheritedFrom = [];
    let siblings = [];

    if (inheritedNode) {
        inheritedFrom = [inheritedNode];
        connectionsTo = [...connectionsTo, ...inheritedNode.inheritedConnections.connectionsTo];
        connectionsFrom = [...connectionsFrom, ...inheritedNode.inheritedConnections.connectionsFrom];
        siblings = await getSiblings(nodeId, inheritedNode.id);
    }

    session.close();

    return { connectionsTo, connectionsFrom, flattenedNodes: [...siblings, ...inheritedFrom, ...inheritors] };
}





// Merged Sibling
/*
async function fetchNodeConnections(nodeId) {
    const session = driver.session();

    const getNodeConnections = async (nodeId) => {
        const resultTo = await session.run(
            `MATCH (n {id: $nodeId})-[r]->(m)
             RETURN m, size((m)--()) AS m_connections`,
            { nodeId }
        );
        const resultFrom = await session.run(
            `MATCH (n)<-[r]-(m)
             WHERE n.id = $nodeId
             RETURN m, size((m)--()) AS m_connections`,
            { nodeId }
        );

        const connectionsTo = [];
        const connectionsFrom = [];

        const processRecord = (record, connectionsArray) => {
            const node = record.get('m').properties;
            const xPositions = node.x_positions;
            const yPositions = node.y_positions;
            const widths = node.widths;
            const heights = node.heights;
            const connectionsCount = record.get('m_connections');

            if (Array.isArray(xPositions) && Array.isArray(yPositions) && xPositions.length === yPositions.length) {
                xPositions.forEach((x, index) => {
                    const y = yPositions[index];
                    connectionsArray.push({
                        ...node,
                        x: Number(x),
                        y: Number(y),
                        width: Number(widths[index]),
                        height: Number(heights[index]),
                        instance: index,
                        connections: connectionsCount
                    });
                });
            } else {
                // Handle the case where x_positions and y_positions arrays are missing or lengths do not match
                connectionsArray.push({
                    ...node,
                    x: null,
                    y: null,
                    width: null,
                    height: null,
                    instance: null,
                    connections: connectionsCount
                });
            }
        };

        resultTo.records.forEach(record => processRecord(record, connectionsTo));
        resultFrom.records.forEach(record => processRecord(record, connectionsFrom));

        return { connectionsTo, connectionsFrom };
    };

    const getInheritedNode = async (nodeId) => {
        const inheritedResult = await session.run(
            `MATCH (n {id: $nodeId})-[:INHERITED_FROM]->(m)
             RETURN m.id AS inheritedId, m`,
            { nodeId }
        );

        if (inheritedResult.records.length > 0) {
            const inheritedNode = inheritedResult.records[0].get('m').properties;
            const inheritedNodeId = inheritedResult.records[0].get('inheritedId');
            const inheritedConnections = await getNodeConnections(inheritedNodeId);

            return {
                ...inheritedNode,
                id: nodeId,
                inheritedConnections
            };
        }

        return null;
    };

    const mergeConnections = (primaryConnections, inheritedConnections) => {
        const mergedConnections = [...primaryConnections];
        const existingNodeIds = new Set(primaryConnections.map(conn => conn.id));

        inheritedConnections.forEach(conn => {
            if (!existingNodeIds.has(conn.id)) {
                mergedConnections.push(conn);
                existingNodeIds.add(conn.id);
            }
        });

        return mergedConnections;
    };

    const mainConnections = await getNodeConnections(nodeId);
    const inheritedNode = await getInheritedNode(nodeId);

    let connectionsTo = mainConnections.connectionsTo;
    let connectionsFrom = mainConnections.connectionsFrom;

    if (inheritedNode) {
        connectionsTo = mergeConnections(connectionsTo, inheritedNode.inheritedConnections.connectionsTo);
        connectionsFrom = mergeConnections(connectionsFrom, inheritedNode.inheritedConnections.connectionsFrom);
    }

    session.close();

    return { connectionsTo, connectionsFrom };
}
*/



/*
async function fetchNodeConnections(nodeId) {
    const session = driver.session();

    const resultTo = await session.run(
        `MATCH (n {id: $nodeId})-[r]->(m)
         RETURN m, size((m)--()) AS m_connections`,
        { nodeId }
    );
    const resultFrom = await session.run(
        `MATCH (n)<-[r]-(m)
         WHERE n.id = $nodeId
         RETURN m, size((m)--()) AS m_connections`,
        { nodeId }
    );
    session.close();

    const connectionsTo = [];
    const connectionsFrom = [];

    const processRecord = (record, connectionsArray) => {
        const node = record.get('m').properties;
        const xPositions = node.x_positions;
        const yPositions = node.y_positions;
	const widths = node.widths;
        const height = node.heights;
        const connectionsCount = record.get('m_connections');

        if (Array.isArray(xPositions) && Array.isArray(yPositions) && xPositions.length === yPositions.length) {
            xPositions.forEach((x, index) => {
                const y = yPositions[index];
                connectionsArray.push({
                    ...node,
                    x: Number(x),
                    y: Number(y),
		    width: Number(widths[index]),
		    height: Number(height[index]),
                    instance: index,
                    connections: connectionsCount
                });
            });
        } else {
            // Handle the case where x_positions and y_positions arrays are missing or lengths do not match
            connectionsArray.push({
                ...node,
                x: null,
                y: null,
		width: null,
		height: null,
                instance: null,
                connections: connectionsCount
            });
        }
    };

    resultTo.records.forEach(record => processRecord(record, connectionsTo));
    resultFrom.records.forEach(record => processRecord(record, connectionsFrom));

    return { connectionsTo, connectionsFrom };
}
*/


async function updateNodePositionInDB(id, x, y, instance) {
    const session = driver.session();
    try {
        // Fetch the current x_positions and y_positions arrays
        const result = await session.run(
            `MATCH (n {id: $id})
             RETURN n.x_positions AS x_positions, n.y_positions AS y_positions`,
            { id }
        );

        if (result.records.length > 0) {
            const record = result.records[0];
            const x_positions = record.get('x_positions');
            const y_positions = record.get('y_positions');

            // Update the specific index in the arrays
            x_positions[instance] = x;
            y_positions[instance] = y;

            // Set the updated arrays back to the node
            await session.run(
                `MATCH (n {id: $id})
                 SET n.x_positions = $x_positions, n.y_positions = $y_positions`,
                { id, x_positions, y_positions }
            );
        }
    } finally {
        session.close();
    }
}

async function updateInheritedNode(id, instance, x, y, width, height) {
    const session = driver.session();
    
    try {
        const result = await session.run(
            `MATCH (n {id: $id})
             RETURN n.x_positions AS x_positions, n.y_positions AS y_positions, n.widths AS widths, n.heights AS heights`,
            { id }
        );

        if (result.records.length === 0) {
            throw new Error(`Node with id ${id} not found`);
        }

        const node = result.records[0];
        let x_positions = node.get('x_positions') || [];
        let y_positions = node.get('y_positions') || [];
        let widths = node.get('widths') || [];
        let heights = node.get('heights') || [];

        // Update specific instance index
        x_positions[instance] = x;
        y_positions[instance] = y;
        widths[instance] = width;
        heights[instance] = height;

        await session.run(
            `MATCH (n {id: $id})
             SET n.x_positions = $x_positions, 
                 n.y_positions = $y_positions, 
                 n.widths = $widths, 
                 n.heights = $heights`,
            { 
                id, 
                x_positions, 
                y_positions, 
                widths, 
                heights 
            }
        );
    } finally {
        await session.close();
    }
}


/*
async function updateNodeProperties(id, label, url, imageUrl, x, y, width, height, instance, type, connectionString, background, code, flake, tests) {
    const session = driver.session();
    
    try {
        const result = await session.run(
            `MATCH (n {id: $id})
             RETURN n.x_positions AS x_positions, n.y_positions AS y_positions, n.widths AS widths, n.heights AS heights`,
            { id }
        );

        if (result.records.length === 0) {
            throw new Error(`Node with id ${id} not found`);
        }

        const node = result.records[0];
        let x_positions = node.get('x_positions') || [];
        let y_positions = node.get('y_positions') || [];
        let widths = node.get('widths') || [];
        let heights = node.get('heights') || [];

        // Update specific instance index
        //x_positions[instance] = x;
        //y_positions[instance] = y;
        widths[instance] = width;
        heights[instance] = height;

	console.log("SAVING TESTS", tests)
	console.log("SAVING FLAKE", flake)
	console.log("SAVING CONNECTIONSTRING", connectionString)

        await session.run(
            `MATCH (n {id: $id})
             SET n.label = $label, 
                 n.url = $url, 
                 n.imageUrl = $imageUrl, 
                 n.x_positions = $x_positions, 
                 n.y_positions = $y_positions, 
                 n.widths = $widths, 
                 n.heights = $heights,
                 n.type = $type,
                 n.connectionString = $connectionString, 
                 n.background = $background,
                 n.code = $code,
	         n.flake = $flake,
	         n.tests = $tests`,
            { 
                id, 
                label, 
                url, 
                imageUrl, 
                x_positions, 
                y_positions, 
                widths, 
                heights,
		type,
		connectionString,
                background, 
                code,
                flake,
		tests
            }
        );
    } finally {
        await session.close();
    }
}
*/

function getCurrentDateWithTimezone() {
    const date = new Date();
    const timezoneOffset = -date.getTimezoneOffset();
    const sign = timezoneOffset >= 0 ? '+' : '-';
    const pad = num => String(num).padStart(2, '0');
    const offsetHours = pad(Math.floor(Math.abs(timezoneOffset) / 60));
    const offsetMinutes = pad(Math.abs(timezoneOffset) % 60);
    const formattedDate = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}${sign}${offsetHours}:${offsetMinutes}`;
}

const CURRENT_LOCATION = "Langkawi, Malaysia"
async function createNodeAndLink(sourceId, x, y, label, url, imageUrl) {
    console.log("CREATED FROM", sourceId, "title: ", label);
    const width = 0;
    const height = 0;
    const type = "node";
    const session = driver.session();
    
    const date = getCurrentDateWithTimezone();

    // Check if a node with the same label already exists
    const existingNodeCheck = await session.run(
        `MATCH (n {label: $label})
         RETURN n`,
        { label }
    );

    if (existingNodeCheck.records.length > 0) {
        // Node with the same label exists, return null or appropriate response
        session.close();
        console.log("Node with the same label already exists");
        return null;
    }

    const result = await session.run(
        `MATCH (source {id: $sourceId})
         CREATE (newNode {
             id: randomUUID(),
             x: $x,
             y: $y,
             x_positions: [$x],
             y_positions: [$y],
             widths: [$width],
             heights: [$height],
             type: $type,
             background: 'rgb(255,219,0)',
             label: $label,
             url: $url,
             imageUrl: $imageUrl,
             date: $date,
             location: $CURRENT_LOCATION
         })
         CREATE (source)-[:CONNECTED_TO]->(newNode)
         RETURN newNode`,
        { sourceId, x, y, width, height, type, label, url, imageUrl, date, CURRENT_LOCATION }
    );

    session.close();
    return result.records[0].get('newNode').properties;
}


async function createNodeAndLink(sourceId, x, y, label, url, imageUrl) {
    console.log("CREATED FROM", sourceId)
    const width = 0;
    const height = 0;
    const type = "node";
    const session = driver.session();
    const result = await session.run(
        `MATCH (source {id: $sourceId})
         CREATE (newNode {
             id: randomUUID(),
             x: $x,
             y: $y,
             x_positions: [$x],
             y_positions: [$y],
             widths: [$width],
             heights: [$height],
             type: $type,
             background: 'rgb(255,219,0)',
             label: $label,
             url: $url,
             imageUrl: $imageUrl
         })
         CREATE (source)-[:CONNECTED_TO]->(newNode)
         RETURN newNode`,
        { sourceId, x, y, width, height, type, label, url, imageUrl }
    );
    session.close();
    return result.records[0].get('newNode').properties;
}

/*
  async function createOrphanNode(x, y) {
  const userInput = await openSearch('Create a new orphan node');
  
  let label = userInput.label;
  let url = "";
  let imageUrl = "";
  let width = 0;
  let height = 0;
  
  if (isValidLink(label)) {
  label = await fetchPageTitle(label);
  url = userInput.label;
  // imageUrl = await getFavicon(label);
  }
  
  if (isYouTubeLink(userInput.label)) {
  imageUrl = getYouTubeThumbnail(userInput.label);
  url = userInput.label;
  }
  
  if (label) {
  const session = driver.session();
  
  // Check if the node already exists
  const checkResult = await session.run(
  `MATCH (existingNode {label: $label})
  RETURN existingNode`,
  { label }
  );
  
  if (checkResult.records.length > 0) {
  // Append to existing node's x_positions and y_positions arrays
  const result = await session.run(
  `MATCH (existingNode {label: $label})
  SET existingNode.x_positions = coalesce(existingNode.x_positions, []) + $x,
  existingNode.y_positions = coalesce(existingNode.y_positions, []) + $y
  RETURN existingNode`,
  { label, x, y }
  );
  session.close();
  return result.records[0].get('existingNode').properties;
  } else {
  // Create a new node with x_positions and y_positions arrays
  const result = await session.run(
  `CREATE (newNode {id: randomUUID(), x_positions: [$x], y_positions: [$y], widths: [$width], heights: $[height], background: 'rgb(255,219,0)', label: $label, url: $url, imageUrl: $imageUrl})
  RETURN newNode`,
  { x, y, width, height, label, url, imageUrl }
  );
  session.close();
  return result.records[0].get('newNode').properties;
  }
  
  drawNodesAndLinks(cur_trans);
  }
  }
*/



async function countInheritedFromConnections(labelProperty) {
    console.log(labelProperty)
  // Open a session
  const session = driver.session();

  try {
    // Run a Cypher query to count the connections
    const result = await session.run(
      `
      MATCH (n {label: $labelProperty})<-[:INHERITED_FROM]-(m)
      RETURN count(m) AS connectionCount
      `,
      { labelProperty }
    );

    // Extract the count from the result
    const count = result.records[0].get('connectionCount').toInt();

    return count;
  } catch (error) {
    console.error('Error counting INHERITED_FROM connections:', error);
    throw error;
  } finally {
    // Close the session
    await session.close();
  }
}


async function createOrphanNode(x, y) {
    const userInput = await openSearch('Create a new orphan node');
    
    let label = userInput.label;
    let url = "";
    let imageUrl = "";
    let width = 0;  // Set default width
    let height = 0; // Set default height
    const date = new Date().toISOString();

    if (isValidLink(label)) {
        label = await fetchPageTitle(label);
        url = userInput.label;
        // imageUrl = await getFavicon(label);
    }
    
    if (isYouTubeLink(userInput.label)) {
        imageUrl = getYouTubeThumbnail(userInput.label);
        url = userInput.label;
    }
    
    if (label) {
        const session = driver.session();
        
        // Check if the node already exists
        const checkResult = await session.run(
            `MATCH (existingNode {label: $label})
             RETURN existingNode`,
            { label }
        );
	


        if (checkResult.records.length > 0) {
	    const existing_connections = await countInheritedFromConnections(label)
	    console.log(existing_connections)
            const newLabel = `${label}_${existing_connections}`;
            const type = "inherited"
            // Create a new node with unique x_positions, y_positions, widths, and heights
            const result = await session.run(
                `CREATE (newNode {id: randomUUID(), x_positions: [$x], y_positions: [$y], widths: [$width], heights: [$height], type: $type, label: $newLabel, url: $url, imageUrl: $imageUrl})
                 WITH newNode
                 MATCH (originalNode {label: $label})
                 CREATE (newNode)-[:INHERITED_FROM]->(originalNode)
                 RETURN newNode`,
                { x, y, width, height, newLabel, label, url, imageUrl, type}
            );
            session.close();
            return result.records[0].get('newNode').properties;
        } else {
            const newLabel = `${label}`;
            const type = "node"
            // Create a new node without inheriting since there's no existing node
            const result = await session.run(
                `CREATE (newNode {id: randomUUID(), x_positions: [$x], y_positions: [$y], widths: [$width], heights: [$height], type: $type, background: 'rgb(255,219,0)', label: $newLabel, url: $url, imageUrl: $imageUrl, date: $date, location: $CURRENT_LOCATION})
                 RETURN newNode`,
                { x, y, width, height, newLabel, url, imageUrl, type, date, CURRENT_LOCATION }
            );
            session.close();
            return result.records[0].get('newNode').properties;
        }
        
        //drawNodesAndLinks(cur_trans);
    }
}











/*
  async function createOrphanNode(x, y) {
  const userInput = await openSearch('Create a new orphan node');
  
  let label = userInput.label;
  let url = "";
  let imageUrl = "";
  let width = 0;  // Set default width
  let height = 0; // Set default height
  
  if (isValidLink(label)) {
  label = await fetchPageTitle(label);
  url = userInput.label;
  // imageUrl = await getFavicon(label);
  }
  
  if (isYouTubeLink(userInput.label)) {
  imageUrl = getYouTubeThumbnail(userInput.label);
  url = userInput.label;
  }
  
  if (label) {
  const session = driver.session();
  
  // Check if the node already exists
  const checkResult = await session.run(
  `MATCH (existingNode {label: $label})
  RETURN existingNode`,
  { label }
  );
  
  if (checkResult.records.length > 0) {
  // Append to existing node's x_positions, y_positions, widths, and heights arrays
  const result = await session.run(
  `MATCH (existingNode {label: $label})
  SET existingNode.x_positions = coalesce(existingNode.x_positions, []) + $x,
  existingNode.y_positions = coalesce(existingNode.y_positions, []) + $y,
  existingNode.widths = coalesce(existingNode.widths, []) + $width,
  existingNode.heights = coalesce(existingNode.heights, []) + $height
  RETURN existingNode`,
  { label, x, y, width, height }
  );
  session.close();
  return result.records[0].get('existingNode').properties;
  } else {
  // Create a new node with x_positions, y_positions, widths, and heights arrays
  const result = await session.run(
  `CREATE (newNode {id: randomUUID(), x_positions: [$x], y_positions: [$y], widths: [$width], heights: [$height], background: 'rgb(255,219,0)', label: $label, url: $url, imageUrl: $imageUrl})
  RETURN newNode`,
  { x, y, width, height, label, url, imageUrl }
  );
  session.close();
  return result.records[0].get('newNode').properties;
  }
  
  drawNodesAndLinks(cur_trans);
  }
  }
*/

async function createGroupingBoxNode(x, y, width, height) {
    const userInput = await openSearch('Create a new grouping box node');
    
    let label = userInput.label;
    let url = "";
    let imageUrl = "";
    
    if (isValidLink(label)) {
        label = await fetchPageTitle(label);
        url = userInput.label;
        // imageUrl = await getFavicon(label);
    }
    
    if (isYouTubeLink(userInput.label)) {
        imageUrl = getYouTubeThumbnail(userInput.label);
        url = userInput.label;
    }
    
    if (label) {
        const session = driver.session();
        
        // Check if the node already exists
        const checkResult = await session.run(
            `MATCH (existingNode {label: $label})
             RETURN existingNode`,
            { label }
        );
        
        if (checkResult.records.length > 0) {
            // Append to existing node's x_positions, y_positions, widths, and heights arrays
            const result = await session.run(
                `MATCH (existingNode {label: $label})
                 SET existingNode.x_positions = coalesce(existingNode.x_positions, []) + $x,
                     existingNode.y_positions = coalesce(existingNode.y_positions, []) + $y,
                     existingNode.widths = coalesce(existingNode.widths, []) + $width,
                     existingNode.heights = coalesce(existingNode.heights, []) + $height
                 RETURN existingNode`,
                { label, x, y, width, height }
            );
            session.close();
            return result.records[0].get('existingNode').properties;
        } else {
            // Create a new node with x_positions, y_positions, widths, heights arrays, and type grouping_box
            const result = await session.run(
                `CREATE (newNode {id: randomUUID(), x_positions: [$x], y_positions: [$y], widths: [$width], heights: [$height], background: 'rgb(255,219,0]', label: $label, url: $url, imageUrl: $imageUrl, type: 'grouping_box'})
                 RETURN newNode`,
                { x, y, width, height, label, url, imageUrl }
            );
            session.close();
            return result.records[0].get('newNode').properties;
        }
        
        drawNodesAndLinks(cur_trans);
    }
}





function drawGrid(transform) {
    cur_trans = transform;
    gridLayer.selectAll(".grid-line").remove(); // Clear existing grid lines

    const width = window.innerWidth;
    const height = window.innerHeight;
    const x0 = -transform.x / transform.k;
    const x1 = (width - transform.x) / transform.k;
    const y0 = -transform.y / transform.k;
    const y1 = (height - transform.y) / transform.k;

    //console.log(`Visible Boundaries: x0=${x0}, x1=${x1}, y0=${y0}, y1=${y1}`);

    const lines = [];

    for (let x = Math.floor(x0 / gridSize) * gridSize; x < x1; x += gridSize) {
        lines.push({ x1: x, y1: y0, x2: x, y2: y1 });
    }
    for (let y = Math.floor(y0 / gridSize) * gridSize; y < y1; y += gridSize) {
        lines.push({ x1: x0, y1: y, x2: x1, y2: y });
    }

    gridLayer.selectAll(".grid-line")
        .data(lines)
        .enter()
        .append("line")
        .attr("class", "grid-line")
        .attr("stroke", "#ddd")
        .attr("stroke-width", 1)
        .attr("x1", d => d.x1)
        .attr("y1", d => d.y1)
        .attr("x2", d => d.x2)
        .attr("y2", d => d.y2);
}

function connectionsToColor(conn, transparency=1.0) {
    connections = Number(conn);
    const colors = [
        { connections: 0, color: [255, 255, 255] }, // White
        { connections: 1, color: [255, 0, 0] },     // Red
        { connections: 4, color: [255, 255, 0] },   // Yellow
        { connections: 7, color: [0, 255, 0] }      // Green
    ];

    // Function to interpolate between two colors
    function interpolateColor(color1, color2, factor) {
        const result = color1.slice();
        for (let i = 0; i < 3; i++) {
            result[i] = Math.round(result[i] + factor * (color2[i] - color1[i]));
        }
        return result;
    }

    // Find the color range the connections value falls into
    let lowerColor = colors[0];
    let upperColor = colors[colors.length - 1];

    for (let i = 0; i < colors.length - 1; i++) {
        if (connections >= colors[i].connections && connections <= colors[i + 1].connections) {
            lowerColor = colors[i];
            upperColor = colors[i + 1];
            break;
        }
    }

    // Calculate the interpolation factor
    const range = upperColor.connections - lowerColor.connections;
    const factor = (connections - lowerColor.connections) / range;

    // Interpolate to get the color
    const color = interpolateColor(lowerColor.color, upperColor.color, factor);
    return `rgb(${color[0]}, ${color[1]}, ${color[2]}, ${transparency})`;
}


async function updateRelationshipType(sourceId, targetId, newType) {
    const session = driver.session();
    await session.run(
        `MATCH (a)-[r]->(b)
         WHERE a.id = $sourceId AND b.id = $targetId
         DELETE r
         CREATE (a)-[newRel:${newType}]->(b)`,
        { sourceId, targetId, newType }
    );
    session.close();
}

async function deleteRelationship(sourceId, targetId) {
    const session = driver.session();
    await session.run(
        `MATCH (a)-[r]->(b)
         WHERE a.id = $sourceId AND b.id = $targetId
         DELETE r`,
        { sourceId, targetId }
    );
    session.close();
}

async function deleteNode(nodeId, instance) {
    const session = driver.session();

    try {
        // Fetch the current x_positions and y_positions arrays
        const result = await session.run(
            'MATCH (n) WHERE n.id = $nodeId RETURN n.x_positions AS x_positions, n.y_positions AS y_positions',
            { nodeId }
        );

        if (result.records.length > 0) {
            const record = result.records[0];
            const x_positions = record.get('x_positions');
            const y_positions = record.get('y_positions');

            if (x_positions.length === 1) {
                // If there is only one position, delete the node and all its relationships
                await session.run(
                    'MATCH (n) WHERE n.id = $nodeId DETACH DELETE n',
                    { nodeId }
                );
                console.log('Node deleted successfully:', nodeId);
            } else {
                // If there are multiple positions, remove the specific position entry
                x_positions.splice(instance, 1);
                y_positions.splice(instance, 1);

                // Update the node with the new positions arrays
                await session.run(
                    'MATCH (n) WHERE n.id = $nodeId SET n.x_positions = $x_positions, n.y_positions = $y_positions',
                    { nodeId, x_positions, y_positions }
                );
                console.log('Position entry deleted successfully for node:', nodeId);
            }
        }
    } catch (error) {
        console.error('Error deleting node or position entry:', error);
        alert('An error occurred while deleting the node or position entry.');
    } finally {
        await session.close();
    }
}



async function createRelationship(sourceId, targetId, type = "CONNECTED_TO") {
    const session = driver.session();
    await session.run(
        `MATCH (a {id: $sourceId}), (b {id: $targetId})
         CREATE (a)-[r:${type}]->(b)
         RETURN r`,
        { sourceId, targetId, type }
    );
    session.close();
}


// V4
function updateLinksAndNodes() {
    // Define arrowhead markers for links
    svg.selectAll("defs").remove(); // Remove existing definitions
    const defs = svg.append("defs");
    defs.append("marker")
        .attr("id", "arrowhead")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 5)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "#999");

    // Function to calculate the new end coordinates for the arrowhead
    function getNewEndCoordinates(sourceX, sourceY, targetX, targetY, radius) {
        const dx = targetX - sourceX;
        const dy = targetY - sourceY;
        const length = Math.sqrt(dx * dx + dy * dy);
        const scale = (length - radius) / length;
        const newTargetX = sourceX + dx * scale;
        const newTargetY = sourceY + dy * scale;
        return { x: newTargetX, y: newTargetY };
    }

    // Helper function to create all possible link instances
    function createLinkData(nodes, links) {
        const newLinks = [];
        links.forEach(link => {
            const sourceNode = nodes.find(n => n.id === link.source);
            const targetNode = nodes.find(n => n.id === link.target);
            sourceNode.x_positions.forEach((_, sourceInstance) => {
                targetNode.x_positions.forEach((_, targetInstance) => {
                    newLinks.push({
                        ...link,
                        sourceInstance,
                        targetInstance
                    });
                });
            });
        });
        return newLinks;
    }

    const updatedLinks = createLinkData(nodes, links);

    // Update links
    const link = linkLayer.selectAll("line").data(updatedLinks, d => `${d.source}-${d.target}-${d.sourceInstance}-${d.targetInstance}`);

    link.exit().remove();

    link.enter()
	.filter(d => d.type !== 'INHERITED_FROM') 
        .append("line")
        .merge(link)
        .attr("stroke", "#999")
        .attr("stroke-width", 2)
        .attr("marker-end", "url(#arrowhead)")
        .attr("x1", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            return sourceNode.x_positions[d.sourceInstance];
        })
        .attr("y1", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            return sourceNode.y_positions[d.sourceInstance];
        })
        .attr("x2", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            const targetNode = nodes.find(n => n.id === d.target);
            const newCoords = getNewEndCoordinates(
                sourceNode.x_positions[d.sourceInstance],
                sourceNode.y_positions[d.sourceInstance],
                targetNode.x_positions[d.targetInstance],
                targetNode.y_positions[d.targetInstance],
                10 // Assuming 10 is the radius of the nodes
            );
            return newCoords.x;
        })
        .attr("y2", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            const targetNode = nodes.find(n => n.id === d.target);
            const newCoords = getNewEndCoordinates(
                sourceNode.x_positions[d.sourceInstance],
                sourceNode.y_positions[d.sourceInstance],
                targetNode.x_positions[d.targetInstance],
                targetNode.y_positions[d.targetInstance],
                10
            );
            return newCoords.y;
        });

    // Update link labels
    const linkLabel = linkLayer.selectAll(".link-label").data(updatedLinks, d => `${d.source}-${d.target}-${d.sourceInstance}-${d.targetInstance}`);

    linkLabel.exit().remove();

    linkLabel.enter()
    	.filter(d => d.type !== 'INHERITED_FROM') 
        .append("text")
        .attr("class", "link-label")
        .merge(linkLabel)
        .attr("x", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            const targetNode = nodes.find(n => n.id === d.target);
            return (sourceNode.x_positions[d.sourceInstance] + targetNode.x_positions[d.targetInstance]) / 2;
        })
        .attr("y", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            const targetNode = nodes.find(n => n.id === d.target);
            return (sourceNode.y_positions[d.sourceInstance] + targetNode.y_positions[d.targetInstance]) / 2;
        })
        .attr("fill", "#eee")
        .attr("font-size", "10px")
        .attr("text-anchor", "middle")
        .attr("dy", -5) // Adjust the position slightly above the link
        .text(d => d.type === "CONNECTED_TO" ? "‚ú¶" : d.type)
        .on("dblclick", async function (event, d) {
            const newType = prompt("Enter new relationship type:", d.type);
            if (newType) {
                await updateRelationshipType(d.source, d.target, newType);
                d.type = newType;
                //drawGrid(cur_trans);
                //drawNodesAndLinks(cur_trans);
            }
        })
        .on("contextmenu", async function (event, d) {
            event.preventDefault();
            const confirmed = confirm("Do you want to delete this interconnection?");
            if (confirmed) {
                await deleteRelationship(d.source, d.target);
                links = links.filter(link => link.source !== d.source || link.target !== d.target);
                //drawGrid(cur_trans);
                //drawNodesAndLinks(cur_trans);
            }
        });


   
    
    // IMPORTANT: Remove redundant nodes! Why are they there in the first place?
    nodes = nodes.reduce((accumulator, currentNode) => {
	if (!accumulator.some(node => node.id === currentNode.id)) {
            accumulator.push(currentNode);
	}
	return accumulator;
    }, []);


    
    
    
    // Separate nodes with and without image URLs
    //const nodesWithImages = nodes.filter(d => d.imageUrl);
    // Default Node with to 10
    // Perhaps faster, more logical if done in the DB
    const DEFAULT_NODE_SIZE = [25,25]
    const DEFAULT_IMAGE_SIZE = [60,60]
    const nodesWithImages = nodes
	  .filter(d => d.imageUrl)
	  .map(d => {
	      d.widths = d.widths.map(width => width === 0 ? DEFAULT_IMAGE_SIZE[0] : width);
	      d.heights = d.heights.map(height => height === 0 ? DEFAULT_IMAGE_SIZE[1] : height);
	      return d;
	  });
    
    const nodesWithoutImages = nodes
	  .filter(d => !d.imageUrl)
	  .map(d => {
	      d.widths = d.widths.map(width => width === 0 ? DEFAULT_NODE_SIZE[0] : width);
	      d.heights = d.heights.map(height => height === 0 ? DEFAULT_NODE_SIZE[1] : height);
	      return d;
	  });

    //const nodesWithoutImages = nodes.filter(d => !d.imageUrl);

    function updateNodePositionAndLinks(d) {
	
// Ensure each link has a unique ID so we can select them for updating
links.forEach(link => {
    link.id = `${link.source.id}-${link.target.id}`;
});

// Append the links (assuming you have a selection for links)
const linkSelection = linkLayer.selectAll('.link').data(links);

linkSelection.enter()
    .append('line')
    .attr('class', 'link')
    .attr('id', d => `link-${d.id}`)
    .attr('x1', d => d.source.x_positions[d.source.instance])
    .attr('y1', d => d.source.y_positions[d.source.instance])
    .attr('x2', d => d.target.x_positions[d.target.instance])
    .attr('y2', d => d.target.y_positions[d.target.instance])
    .attr('stroke', 'gray')
    .merge(linkSelection);

	linkSelection.exit().remove();
	
        // Update the node's position in the nodes array
        nodes.find(n => n.id === d.id).x_positions[d.instance] = d.x;
        nodes.find(n => n.id === d.id).y_positions[d.instance] = d.y;
	//console.log(nodes.find(n => n.id === d.id));

        // Update the links connected to the node
        linkLayer.selectAll("line")
            .attr("x1", l => nodes.find(n => n.id === l.source).x_positions[l.sourceInstance])
            .attr("y1", l => nodes.find(n => n.id === l.source).y_positions[l.sourceInstance])
            .attr("x2", l => {
                const sourceNode = nodes.find(n => n.id === l.source);
                const targetNode = nodes.find(n => n.id === l.target);
                const newCoords = getNewEndCoordinates(sourceNode.x_positions[l.sourceInstance], sourceNode.y_positions[l.sourceInstance], targetNode.x_positions[l.targetInstance], targetNode.y_positions[l.targetInstance], 10);
                return newCoords.x;
            })
            .attr("y2", l => {
                const sourceNode = nodes.find(n => n.id === l.source);
                const targetNode = nodes.find(n => n.id === l.target);
                const newCoords = getNewEndCoordinates(sourceNode.x_positions[l.sourceInstance], sourceNode.y_positions[l.sourceInstance], targetNode.x_positions[l.targetInstance], targetNode.y_positions[l.targetInstance], 10);
                return newCoords.y;
            });

        // Update link labels position
        linkLayer.selectAll(".link-label")
            .attr("x", l => {
                const sourceNode = nodes.find(n => n.id === l.source);
                const targetNode = nodes.find(n => n.id === l.target);
                return (sourceNode.x_positions[l.sourceInstance] + targetNode.x_positions[l.targetInstance]) / 2;
            })
            .attr("y", l => {
                const sourceNode = nodes.find(n => n.id === l.source);
                const targetNode = nodes.find(n => n.id === l.target);
                return (sourceNode.y_positions[l.sourceInstance] + targetNode.y_positions[l.targetInstance]) / 2;
            });


	

        // Update labels position

	
    // Update labels
    const labels = nodeLayer.selectAll("text").data(nodes, d => d.id);

    labels.exit().remove();

    labels.enter()
        .append("text")
            .merge(labels)
		.attr("x", d => {
	    //console.log("FK", d.widths[d.instance])
	    if (d.widths[d.instance] === DEFAULT_NODE_SIZE[0] || d.widths[d.instance] === DEFAULT_IMAGE_SIZE[0]) {
		return d.x_positions[d.instance] + d.widths[d.instance] / 2 + 3;
	    } else {
		return d.x_positions[d.instance] - d.widths[d.instance] / 2;
	    }
	})
	.attr("y", d => {
	    if (d.widths[d.instance] === DEFAULT_NODE_SIZE[1] || d.widths[d.instance] === DEFAULT_IMAGE_SIZE[1]) {
		return d.y_positions[d.instance] + 3;
	    } else {
		return d.y_positions[d.instance] + d.heights[d.instance] / 2 + 15;
	    }
	})
        //    .attr("x", d => d.imageUrl ? d.x_positions[d.instance] + d.widths[d.instance]/2 + 5 : d.x_positions[d.instance] + 16)  // Adjust x position based on node type
        //.attr("y", d => d.imageUrl ? d.y_positions[d.instance] + 3 : d.y_positions[d.instance] + 3)
        .text(d => {
	    if (isYouTubeLink(d.url)) {
		return `${d.label} üé¨`;  // Adds video emoji for YouTube links
	    } else if (d.url) {
		return `${d.label} üåê`;  // Adds internet emoji for other links
	    } else {
		return d.label;
	    }
	}) //.text(d => d.url ? `${d.label} üåê` : d.label) //.text(d => d.label)
        .attr("label", d => d.label)
        .attr("instance", d => d.instance)
        .attr("font-size", "12px")
        .attr("fill", "#eee")
//        nodeLayer.selectAll("text")	
 //           .attr("x", d => d.imageUrl ? d.x_positions[d.instance] + 30 : d.x_positions[d.instance] + 10)  // Adjust x position based on node type
  //          .attr("y", d => d.imageUrl ? d.y_positions[d.instance] + 10 : d.y_positions[d.instance])
//            .attr("x", //t => t.imageUrl ? t.x_positions[t.instance] + 30 : t.x_positions[t.instance] + 10)
  //          .attr("y", //t => t.imageUrl ? t.y_positions[t.instance] + 10 : t.y_positions[t.instance]);

	//nodeLayer.selectAll("text")
        //    .attr("cx", n => n.x_positions[n.instance])
         //   .attr("cy", n => n.y_positions[n.instance]);

    
        // Update circle positions
        //nodeLayer.selectAll("onenode")
        //    .attr("cx", n => n.x_positions[n.instance])
         //   .attr("cy", n => n.y_positions[n.instance]);

        // Update image positions
        //nodeLayer.selectAll("image")
        //    .attr("x", n => n.x_positions[n.instance] - n.widths[n.instance]/2)
         //   .attr("y", n => n.y_positions[n.instance] - n.heights[n.instance]/2);
    }

    function findLabel(label, instance) {
	return nodeLayer.selectAll("text")
            .filter(function(d) {
		return d.label === label && d.instance === instance;
            })
            .node(); // returns the first matching element or null if none found
    }

    function findAllLabels(p) {
    //console.log(p);
    let label = p.label;
    let instance = p.instance;
    let xPosition = p.x_positions[instance];

    // Select and delete nodes that match the label and instance but do not have the same x_position
    nodeLayer.selectAll("rect")
        .filter(function(d) {
            return d.label === label && d.instance === instance && d.x_positions[instance] !== xPosition;
        })
        .remove();

    /*nodeLayer.selectAll("image")
        .filter(function(d) {
            return d.label === label && d.instance === instance && d.x_positions[instance] !== xPosition;
        })
        .remove();
*/
	
    // Return the remaining nodes that match the criteria
    return nodeLayer.selectAll("text")
        .filter(function(d) {
            return d.label === label && d.instance === instance && d.x_positions[instance] === xPosition;
        })
        .nodes(); // returns an array of all matching elements
}

    
        
    function setupDragBehavior(selection) {
        selection.call(d3.drag()
		       .on("start", function (event, d) {
			   d3.select(this).raise().attr("stroke", "white");
		       })
		       .on("drag", async function (event, d) {
			    //d3.select(this).remove();
			   /*if (d.x_positions.length >= 1) {
			      
			       //d3.select(findLabel(d.label, d.instance)).remove();
			   }*/
			   //console.log("MERP", event,d)
			   d.x = event.x;
			   d.y = event.y;

			   //console.log(findAllLabels(d.label, d.instance))
			   // Update the position of the dragged element
			   d3.select(this)
			       .attr("cx", d.x - (d.widths[d.instance]/2) )
			       .attr("cy", d.y - (d.heights[d.instance]/2) )
			       .attr("x",  d.x - (d.widths[d.instance]/2) )  // For images
			       .attr("y",  d.y - (d.heights[d.instance]/2) ); // For images

			   
			   updateNodePositionAndLinks(d);
			   // Use MathJax to process the SVG elements
			   //MathJax.Hub.Queue(["Typeset", MathJax.Hub, svg.node()]);
			   
			   
			   //drawNodesAndLinks(cur_trans);
			   //await updateNodePosition(d.id, d.x, d.y, d.instance);
			   //await updateNodePosition(d.id, d.x, d.y, d.instance);

			   // Update inspector with current position
			   //document.getElementById("nodeX").value = d.x;
			   //document.getElementById("nodeY").value = d.y;
			   // Center view on the dragged node
			   //svg.transition().duration(0).call(zoom.translateTo, d.x, d.y);
			   //svg.transition()
			   //    .duration(0)
			   //    .call(zoom.transform, d3.zoomIdentity.translate(svgWidth / 2 - d.x, svgHeight / 2 - d.y));
		       })
		       .on("end", async function (event, d) {
			   d3.select(this).attr("stroke", null);
			   await updateNodePositionInDB(d.id, d.x, d.y, d.instance);


			   //updateNodePositionAndLinks(d);
			   //drawNodesAndLinks(cur_trans);
		       })
		      );
    }
    /*
    // Update circles
    rect = nodeLayer.selectAll("rect").data(nodesWithoutImages, d => d.id);

    rect.exit().remove();

    rect.enter()
    .append("rect")
    .attr("width", d => Number(d.widths[d.instance]) || 20)  // Ensure width is a number, defaults to 20
    .attr("height", d => Number(d.heights[d.instance]) || 20) // Ensure height is a number, defaults to 20
    .attr("x", d => Number(d.x_positions[d.instance]) - (Number(d.widths[d.instance]) / 2 || 10)) // Centering the rectangle
    .attr("y", d => Number(d.y_positions[d.instance]) - (Number(d.heights[d.instance]) / 2 || 10)) // Centering the rectangle
    .attr("rx", d => {
    const width = Number(d.widths[d.instance]) || 20;
    return Math.max(0, (20 - (width - 20) * 0.1)); // Decrease corner radius as width increases
    })
    .attr("ry", d => {
    const height = Number(d.heights[d.instance]) || 20;
    return Math.max(0, (20 - (height - 20) * 0.1)); // Decrease corner radius as height increases
    })
    .merge(rect)
    .attr("label", d => d.label)
    .attr("instance", d => d.instance)
    .attr("cx", d => d.x_positions[d.instance])
    .attr("cy", d => d.y_positions[d.instance])
    .attr("fill", d => {
    if (d.type === "grouping_box") {
    return "rgba(128, 0, 128, 0.1)"; // Partially transparent purple
    } else {
    return connectionsToColor(d.connections) || "red";
    }
    })
    .attr("stroke", d => {
    if (d.type === "grouping_box") {
    return "purple";
    } else {
    return "none"; // Default stroke if not a grouping box
    }
    })
    .attr("stroke-dasharray", d => {
    if (d.type === "grouping_box") {
    return "4 2"; // Dashed line
    } else {
    return "none"; // Default stroke-dasharray if not a grouping box
    }
    })
    .on("mousedown", async function (event, d) {
    selectNode(event, d);
    })
    .call(setupDragBehavior)
    .on("contextmenu", async function (event, d) {
    event.preventDefault();
    const confirmed = confirm("Do you want to delete this node?");
    if (confirmed) {
    await deleteNode(d.id, d.instance);
    
    // Remove the node and its related links from the data
    nodes = nodes.filter(node => node.id !== d.id);
    links = links.filter(link => link.source.id !== d.id && link.target.id !== d.id);
    
    // Redraw the grid and nodes/links
    drawGrid(cur_trans);
    drawNodesAndLinks(cur_trans);
    }
    })
    .on("dblclick", async (event, d) => {
    // Handle double-click event
    });

    // Remove old rects before appending new ones
    rect.exit().remove();
    */
    // Separate the nodes based on their type
    
    //const inheritedNodes = nodesWithoutImages.filter(d => d.type === 'inherited');
    const groupingNodes = nodesWithoutImages.filter(d => d.type === 'grouping_box');
    const inheritedNodes = nodesWithoutImages.filter(d => d.type === 'inherited');
    const regularNodes = nodesWithoutImages.filter(d => d.type !== 'grouping_box' && d.type !== 'inherited');



    // Function to update rects
    function updateRects(layer, data, fill, stroke, strokeDasharray) {

	
	let rect = layer.selectAll("rect").data(data, d => d.id);

	rect.exit().remove();

	rect.enter()
            .append("rect")    
            .attr("width", d => Number(d.widths[d.instance]))  // Ensure width is a number, defaults to 20
            .attr("height", d => Number(d.heights[d.instance])) // Ensure height is a number, defaults to 20
            .attr("x", d => Number(d.x_positions[d.instance]) - (Number(d.widths[d.instance]) / 2 || 10)) // Centering the rectangle
            .attr("y", d => Number(d.y_positions[d.instance]) - (Number(d.heights[d.instance]) / 2 || 10)) // Centering the rectangle
            .attr("rx", d => {
		const width = Number(d.widths[d.instance]) || 20;
		return Math.max(0, (20 - (width - 20) * 0.1)); // Decrease corner radius as width increases
            })
            .attr("ry", d => {
		const height = Number(d.heights[d.instance]) || 20;
		return Math.max(0, (20 - (height - 20) * 0.1)); // Decrease corner radius as height increases
            })
            .merge(rect)
            .attr("label", d => d.label)
            .attr("instance", d => d.instance)
            .attr("cx", d => d.x_positions[d.instance])
            .attr("cy", d => d.y_positions[d.instance])
            .attr("fill", fill)
            .attr("stroke", stroke)
            .attr("stroke-dasharray", strokeDasharray)
            .on("mousedown", async function (event, d) {
		selectNode(event, d);

		// highlight last selected node
                if (lastSelectedNode) {
                    d3.select(lastSelectedNode).classed("highlight", false);
                }
                d3.select(this).classed("highlight", true);
                lastSelectedNode = this;
		
		
		const currentTime = new Date().getTime();
		const timeSinceLastClick = currentTime - lastClickTime;
		
		if (timeSinceLastClick < doubleClickThreshold) {
		    await handleDoubleClick(event);
		} else {
		    // Single click
		}
		
		lastClickTime = currentTime;
            })
            .call(setupDragBehavior)
            .on("contextmenu", async function (event, d) {
		event.preventDefault();
		const confirmed = confirm("Do you want to delete this node?");
		if (confirmed) {
                    await deleteNode(d.id, d.instance);
                    
                    // Remove the node and its related links from the data
                    nodes = nodes.filter(node => node.id !== d.id);
                    links = links.filter(link => link.source.id !== d.id && link.target.id !== d.id);
                    
                    // Redraw the grid and nodes/links
                    //drawGrid(cur_trans);
                    //drawNodesAndLinks(cur_trans);
		}
            })
            .on("dblclick", async (event, d) => {
		console.log("GOT DBLCLK")
		// Handle double-click event
            });
    }


    
    // Update rects for groupingLayer
    updateRects(groupingLayer, groupingNodes, "rgba(128, 0, 128, 0.1)", "purple", "4 2");
    updateRects(inheritedLayer, inheritedNodes, d => connectionsToColor(d.connections, transparency = 0.5) || "red", d => connectionsToColor(d.connections, transparency = 0.5) || "red", "3 3");

    // Update rects for nodeLayer
    updateRects(nodeLayer, regularNodes, d => connectionsToColor(d.connections) || "red", "none", "none");

    
    // Define a function to get a unique identifier for each rect
    function getUniqueId(d) {
	return d.label + d.instance;
    }    
    // Update images
    const image = nodeLayer.selectAll("image").data(nodesWithImages, d => d.id);

    image.exit().remove();

    image.enter()
        .append("image")
        .attr("width",  d => d.widths[d.instance])  // Adjust width as needed
        .attr("height",  d => d.heights[d.instance]) // Adjust height as needed
        .attr("x", d => Number(d.x_positions[d.instance]) - (Number(d.widths[d.instance]) / 2 || 10))
        .attr("y", d => Number(d.y_positions[d.instance]) - (Number(d.heights[d.instance]) / 2 || 10))
        .attr("xlink:href", d => { //.attr("xlink:href", d => d.imageUrl)
	    if (d.imageUrl.startsWith('/uploads')) {
		// make electron happy
		// this is backwards compatibility with my old nodes
		return `${__dirname}${d.imageUrl}`;
	    }

	    return d.imageUrl;
	})

	  .attr("stroke", d => connectionsToColor(d.connections) || "red", "none", "none")
	  .attr("stroke-dasharray", "3 3")

        .on("error", function () {
            d3.select(this).attr("xlink:href", "images/image-load-failed.png"); // Fallback image if link is bad
	})
        .merge(image)
    
        .style("filter", d => `drop-shadow(0px 0px 3px ${connectionsToColor(d.connections) || "red"})`)
        .on("mousedown", async function (event, d) {
            selectNode(event, d);

	    // highlight last selected node
	    // TODO Highlight images when selected
            /*    if (lastSelectedNode) {
                    d3.select(lastSelectedNode).classed("highlight", false);
                }
                d3.select(this).classed("highlight", true);
                lastSelectedNode = this;
	    */
	    
        })
        .call(setupDragBehavior)
        .on("contextmenu", async function (event, d) {
            event.preventDefault();
            const confirmed = confirm("Do you want to delete this node?");
            if (confirmed) {
                await deleteNode(d.id, d.instance);
                
                // Remove the node and its related links from the data
                nodes = nodes.filter(node => node.id !== d.id);
                links = links.filter(link => link.source.id !== d.id && link.target.id !== d.id);
                
                // Redraw the grid and nodes/links
                //drawGrid(cur_trans);
                //drawNodesAndLinks(cur_trans);
            }
        });
        /*.on("dblclick", async (event, d) => {
            const newX = d.x; // New node's X coordinate
            const newY = d.y + 30; // New node's Y coordinate
            const userInput = openSearch('Create a new node with shift+enter or connect to an existing node');
            
            let label = userInput.label;
            let url = "";
            let imageUrl = "";

            if (isValidLink(label)) {
                label = await fetchPageTitle(label);
                url = label;
                // imageUrl = await getFavicon(label);
            }

            if (isYouTubeLink(userInput.label)) {
                imageUrl = getYouTubeThumbnail(userInput.label);
                url = userInput.label;
            }
            
            if (label) {
                if (!userInput.exists) {
                    await createNodeAndLink(d.id, newX, newY, label, url, imageUrl);
                } else {
                    await connectToNode(d.id, label);
                }
                drawNodesAndLinks(cur_trans);
            }
        });*/

    // Update labels
    const labels = nodeLayer.selectAll("text").data(nodes, d => d.id);

    labels.exit().remove();

    labels.enter()
        .append("text")
        .merge(labels)
	.attr("x", d => {
	    //console.log("FK", d.widths[d.instance])
	    if (d.widths[d.instance] === DEFAULT_NODE_SIZE[0] || d.widths[d.instance] === DEFAULT_IMAGE_SIZE[0]) {
		return d.x_positions[d.instance] + d.widths[d.instance] / 2 + 3;
	    } else {
		return d.x_positions[d.instance] - d.widths[d.instance] / 2;
	    }
	})
	.attr("y", d => {
	    if (d.widths[d.instance] === DEFAULT_NODE_SIZE[1] || d.widths[d.instance] === DEFAULT_IMAGE_SIZE[1]) {
		return d.y_positions[d.instance] + 3;
	    } else {
		return d.y_positions[d.instance] + d.heights[d.instance] / 2 + 15;
	    }
	})
        //.attr("x", d => d.imageUrl ? d.x_positions[d.instance] + d.widths[d.instance]/2 + 5 : d.x_positions[d.instance] + d.widths[d.instance]/2 + 5)  // Adjust x position based on node type
        //.attr("y", d => d.imageUrl ? d.y_positions[d.instance] + 3: d.y_positions[d.instance] + 3 )
        .text(d => {
	    if (isYouTubeLink(d.url)) {
		return `${d.label} üé¨`;  // Adds video emoji for YouTube links
	    } else if (d.url) {
		return `${d.label} üåê`;  // Adds internet emoji for other links
	    } else {
		return d.label;
	    }
	}) //.text(d => d.url ? `${d.label} üåê` : d.label) //.text(d => d.label)
        .attr("label", d => d.label)
        .attr("instance", d => d.instance)
        .attr("font-size", "12px")
        .attr("fill", "#eee")
}



async function drawNodesAndLinks(transform) {
    const width = window.innerWidth;
    const height = window.innerHeight;
    const x0 = -transform.x / transform.k;
    const x1 = (width - transform.x) / transform.k;
    const y0 = -transform.y / transform.k;
    const y1 = (height - transform.y) / transform.k;

    // Get nodes and links in current viewport from neo4j
    const { nodes, links } = await fetchNodesAndLinks(x0, x1, y0, y1);

    
    updateLinksAndNodes();
}


async function fetchPageTitle(url) {
    const proxyUrl = `${encodeURIComponent(url)}`;

    try {
        const response = await fetch(proxyUrl);
        const text = await response.text();
        console.log('Fetched HTML:', text);  // Log the fetched HTML
        const parser = new DOMParser();
        const doc = parser.parseFromString(text, 'text/html');
        const titleElement = doc.querySelector('title');
        if (titleElement) {
            return titleElement.innerText;
        } else {
            console.warn('No title element found for URL:', url);
            return url;
        }
    } catch (error) {
        console.error("Error fetching title:", error);
        return "Failed to fetch title.";
    }
}

function isValidLink(url) {
    const urlPattern = new RegExp(
        '^(https?:\\/\\/)' + // protocol (required)
            '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.?)+[a-z]{2,}|' + // domain name
            '((\\d{1,3}\\.){3}\\d{1,3})|' + // OR ip (v4) address
            '\\[([a-f\\d]{1,4}:){7,7}[a-f\\d]{1,4}\\]|' + // OR ip (v6) address
            'localhost)' + // OR localhost
            '(\\:\\d+)?' + // port (optional)
            '(\\/[-a-z\\d%_.~+]*)*' + // path (optional)
            '(\\?[;&a-z\\d%_.~+=-]*)?' + // query string (optional)
            '(\\#[-a-z\\d_]*)?$', 'i' // fragment locator (optional)
    );
    return urlPattern.test(url);
}



function isYouTubeLink(url) {
    const youtubeRegex = /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/.+$/;
    return youtubeRegex.test(url);
}


async function connectToNode(nodeId, nodeTo="") {
    let targetLabel;
    let resultExists;
    if (nodeTo === "") {
	// Prompt the user for the label of the node to connect to
	const searchResult = await openSearch('Search for a node to connect to');
	targetLabel = searchResult.label;
	resultExists = searchResult.exists;
    } else {
	targetLabel = nodeTo;
	resultExists = true;
    }
    
    if (targetLabel && resultExists) {
        const session = driver.session();

        try {
            // Find the target node with the specified label
            const result = await session.run(
                'MATCH (targetNode {label: $label}) RETURN targetNode LIMIT 1',
                { label: targetLabel }
            );

            if (result.records.length > 0) {
                const targetNode = result.records[0].get('targetNode');
                const targetNodeId = targetNode.properties.id;

                console.log('Target node found:', targetNode);

                // Create the relationship between the current node and the target node using the id property
                const connectResult = await session.run(
                    'MATCH (n1 {id: $nodeId}), (n2 {id: $targetNodeId}) CREATE (n1)-[:CONNECTED_TO]->(n2) RETURN n1, n2',
                    { nodeId: nodeId, targetNodeId: targetNodeId }
                );

                console.log('Connect result:', connectResult);

                if (connectResult.records.length > 0) {
                    //alert('Nodes connected successfully!');
                } else {
                    alert('Failed to create the connection.');
                }
            } else {
                alert('No node found with the specified label.');
            }
        } catch (error) {
            console.error('Error connecting nodes:', error);
            alert('An error occurred while connecting the nodes.');
        } finally {
            await session.close();
        }
    }
}


async function connectFromNode(nodeId) {
    // Prompt the user for the label of the node to connect from
    const searchResult = await openSearch('Search for the node to connect from');
    sourceLabel = searchResult.label
    
    if (sourceLabel && searchResult.exists) {
        const session = driver.session();

        try {
            // Find the source node with the specified label
            const result = await session.run(
                'MATCH (sourceNode {label: $label}) RETURN sourceNode LIMIT 1',
                { label: sourceLabel }
            );

            if (result.records.length > 0) {
                const sourceNode = result.records[0].get('sourceNode');
                const sourceNodeId = sourceNode.properties.id;

                console.log('Source node found:', sourceNode);

                // Create the relationship between the source node and the current node using the id property
                const connectResult = await session.run(
                    'MATCH (n1 {id: $sourceNodeId}), (n2 {id: $nodeId}) CREATE (n1)-[:CONNECTED_TO]->(n2) RETURN n1, n2',
                    { sourceNodeId: sourceNodeId, nodeId: nodeId }
                );

                console.log('Connect result:', connectResult);

                if (connectResult.records.length > 0) {
                    alert('Nodes connected successfully!');
                } else {
                    alert('Failed to create the connection.');
                }
            } else {
                alert('No node found with the specified label.');
            }
        } catch (error) {
            console.error('Error connecting nodes:', error);
            alert('An error occurred while connecting the nodes.');
        } finally {
            await session.close();
        }
    }
}

async function writeFileToRemote(connectionString, remotePath, fileContent) {
  const [usernamePart, hostPart] = connectionString.split('@');
  const [ip, port = '22'] = hostPart.split(':'); // Default to port 22 if not provided
  const username = usernamePart;

  const url = '/write-file';

  // Prompt the user for the password each time
  const password = "none" //window.prompt("Please enter your password:");
  if (!password) {
    console.error('Password is required to proceed.');
    return;
  }

  const data = {
    ip: ip,
    port: parseInt(port, 10), // Ensure the port is a number
    username: username,
    password: password,
    remotePath: remotePath,
    fileContent: fileContent
  };

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    const result = await response.json();
    console.log('File written successfully:', result);
    return result;
  } catch (error) {
    console.error('Error writing file to remote server:', error);
    throw error;
  }
}

// Function to check if connection string is defined and prompt user if not
async function checkAndUpdateNodeConnectionString(nodeId) {
    const property = "connectionString";
    let connString =  document.getElementById("nodeConnectionString").value; //currentNode.connectionString;

    if (connString) {
        // Return the existing connection string if it is already defined
        return connString;
    }

    // Prompt the user to create a connection string if it is undefined
    const userInput = prompt("The connection string is undefined. Please create it:");

    // If the user provides input, set it to the connString
    if (userInput) {
        connString = userInput;
        // Proceed with updating the node property with the new connection string
        try {
            await updateNodeProperty(nodeId, property, connString);
            alert("Node property updated successfully.");
            return connString; // Return the new connection string
        } catch (error) {
            console.error("Error updating node property:", error);
            alert("Failed to update node property.");
            return null; // Indicate that there was an error
        }
    } else {
        // If the user cancels or doesn't provide input, return without updating the property
        alert("Operation cancelled. Connection string is required.");
        return null; // Indicate that the operation was cancelled
    }
}



async function runCommand() {
    const connString = await checkAndUpdateNodeConnectionString(currentNode.id)
    const nodeLabel = document.getElementById("nodeLabel").value;
    const nodeCode = document.getElementById("nodeCode").value;
    const nodeFlake = document.getElementById("nodeFlake").value;
    console.log("DOIN IT")
    //runRemoteCommand(connString, "cd ~/neopkm_nodes/ && ls", )
    /*writeFileToRemote(connString, `~/neopkm/${nodeLabel}/flake.nix`, nodeFlake)
	.then(result => console.log(result))
	.catch(error => console.error(error));

    writeFileToRemote(connString, `~/neopkm/${nodeLabel}/${nodeLabel}`, nodeCode)
	.then(result => console.log(result))
	.catch(error => console.error(error));

    writeFileToRemote(connString, `~/neopkm/${nodeLabel}/tests.json`, convertTableToJSONString())
	.then(result => console.log(result))
	.catch(error => console.error(error));*/

    Promise.all([
	writeFileToRemote(connString, `~/neopkm/${nodeLabel}/flake.nix`, nodeFlake),
	writeFileToRemote(connString, `~/neopkm/${nodeLabel}/${nodeLabel}`, nodeCode),
	writeFileToRemote(connString, `~/neopkm/${nodeLabel}/tests.json`, convertTableToJSONString())
    ])
	.then(results => {
	    console.log(results);
	    // Set the iframe URL after all promises are resolved
	    document.getElementById('consoleContainer').src = `http://localhost:8080/?arg=nix%20develop%20/home/printer/neopkm/${nodeLabel}`;
	})
	.catch(error => {
	    console.error(error);
	});
    

}

// When clicking on a node that's inherited, it should actually get THE CODE of the node it's inherited from
/*async function getInheritedCode(nodeId) {
    const session = driver.session();
    const query = `
        MATCH (child {id: $nodeId})-[:INHERITED_FROM]->(parent)
        RETURN parent.code AS code
    `;
    const result = await session.run(query, { nodeId });
    if (result.records.length === 0) {
        return null; // No parent or no code property found
    }
    return result.records[0].get('code');
}

async function getInheritedFlake(nodeId) {
    const session = driver.session();
    const query = `
        MATCH (child {id: $nodeId})-[:INHERITED_FROM]->(parent)
        RETURN parent.flake AS flake
    `;
    const result = await session.run(query, { nodeId });
    if (result.records.length === 0) {
        return null; // No parent or no flake property found
    }
    return result.records[0].get('flake');
}
*/

async function getInheritedProperties(nodeId) {
    const session = driver.session();
    const query = `
        MATCH (child {id: $nodeId})-[:INHERITED_FROM]->(parent)
        RETURN properties(parent) AS properties
    `;
    const result = await session.run(query, { nodeId });
    if (result.records.length === 0) {
        return null; // No parent found
    }
    return result.records[0].get('properties');
}

function setTableEditable(isEditable) {
    const table = document.getElementById('nodeTestsTable').getElementsByTagName('tbody')[0];
    const cells = table.getElementsByTagName('td');
    const deleteButtons = table.getElementsByClassName('delete-btn');

    for (let cell of cells) {
        cell.setAttribute('contenteditable', isEditable);
    }

    for (let deleteButton of deleteButtons) {
        deleteButton.style.display = isEditable ? 'table-cell' : 'none';
    }
}

      
/*function setReadOnlyFields(isReadOnly) {
    document.getElementById("nodeId").readOnly = isReadOnly;
    document.getElementById("nodeLabel").readOnly = isReadOnly;
    document.getElementById("nodeUrl").readOnly = isReadOnly;
    document.getElementById("nodeImageUrl").readOnly = isReadOnly;
    document.getElementById("nodeInstance").readOnly = isReadOnly;
    document.getElementById("nodeBackground").readOnly = isReadOnly;
    document.getElementById("nodeType").readOnly = isReadOnly;
    document.getElementById("connectionString").readOnly = isReadOnly;
    document.getElementById("nodeCode").readOnly = isReadOnly;
    document.getElementById("nodeFlake").readOnly = isReadOnly;

    setTableEditable(!isReadOnly);
}*/

      function hasCodeExtension(label) {
	  const validExtensions = [".nix", ".py", ".sh", ".js"];
	  return validExtensions.some(ext => label.includes(ext));
      }

      

function setupNodeViewerWindow(d) {

    if (isYouTubeLink(d.url) === true) {
	toggleSection('video-container', display="flex")

	setVideoUrl(d);
	//setVideoTitle(d.label);
    } else if (d.url.length > 1) {
	//toggleSection('web-container', action="show")

	createWebView(d.label, d.url)
	/*
	console.log(`setting webviewElement to ${d.url}`)
	if (d.url.includes(".pdf")) {
	    
	    document.getElementById('webviewElement').src = `${d.url}`; // /proxy?url=
	} else {
	    document.getElementById('webviewElement').src = `${d.url}`; // /proxy?url=
	}
	document.getElementById('webviewElement').style.display = "flex";
	document.getElementById('player').style.display = "none";*/
	//restoreScrollPosition(d);    
    } else {
	//toggleSection('video-container', action="hide")
    }
}


function createInspector(d, readOnly = false) {
    // Get the propertyDiv element
    const propertyDiv = document.getElementById('propertyDiv');

    // Clear the propertyDiv content and remove old event listeners
    while (propertyDiv.firstChild) {
        propertyDiv.removeChild(propertyDiv.firstChild);
    }

    // Array of blacklisted properties
    const blacklist = ['x_positions', 'y_positions', 'widths', 'heights', 'type', 'background', 'x', 'y', 'width', 'height', 'instance', 'videoTime', 'scrollPosition', 'id', 'connections', 'code', 'flake', 'tests'];

    const prefOrder = ['label', 'location', 'date', 'imageUrl', 'url'];

    // Create a set to track processed keys
    const processedKeys = new Set();

    // Function to create and append input elements
    function createInput(key, value) {
        const div = document.createElement('div');
        div.style.display = 'flex';
        div.style.alignItems = 'center';
        div.style.marginBottom = '5px';

        const label = document.createElement('label');
        label.style.width = '5em';
        label.innerText = key.charAt(0).toUpperCase() + key.slice(1);
        div.appendChild(label);

        const input = document.createElement('input');
        input.type = typeof value === 'number' ? 'number' : 'text';
        input.id = `node${key.charAt(0).toUpperCase() + key.slice(1)}`;
        input.style.flex = '1';
        input.value = value;
        input.readOnly = readOnly;
        div.appendChild(input);

        // Add event listener to handle input changes
        input.addEventListener('input', async (event) => {
            const nodeId = currentNode.id;
            const property = key;
            const newValue = event.target.type === 'number' ? parseFloat(event.target.value) : event.target.value;

            console.log(`Updating property ${property} with value ${newValue}`);
            await updateNodeProperty(nodeId, property, newValue);

	    if (property === "label") {
		currentNode.label = newValue;
		// Dynamically update sections based on currently input label
		// Valid codeextensions will open more windows
	        setupSections(newValue); 
		const labelElement = nodeLayer.selectAll("text").filter(d => d.id === nodeId).text(newValue);
	    }

        });

        propertyDiv.appendChild(div);
    }

    // Process properties in preferred order
    prefOrder.forEach(key => {
        if (d.hasOwnProperty(key) && !blacklist.includes(key)) {
            createInput(key, d[key]);
            processedKeys.add(key);
        }
    });

    // Process remaining properties
    for (let key in d) {
        if (d.hasOwnProperty(key) && !blacklist.includes(key) && !processedKeys.has(key)) {
            createInput(key, d[key]);
        }
    }
}


// Sections for code nodes
function setupSections(label) {
    if (hasCodeExtension(label) === true) {
	toggleSection('code-editor', display="flex")
	toggleSection('flake-editor', display="flex")
	toggleSection('test-editor', display="flex")
	toggleSection('console-container', display="flex")
    } else {
	toggleSection('flake-editor', display="none")
	toggleSection('test-editor', display="none")
	toggleSection('console-container', display="none")
    }
    updateConfigNodeProperty("sectionState",getSectionsState())
}

async function selectNode(event, d) {
    
    const inspector = document.getElementById("inspector");
    const codeEditor = document.getElementById("code-editor");
    let inheritedProperties;
    

    // TODO modify this to inherit EVERYTHING at once
    if (d.type === "inherited") {

	inheritedProperties = await getInheritedProperties(d.id);

	createInspector(inheritedProperties, readOnly=true);
	
	loadFromJSON(inheritedProperties.tests)

	setupNodeViewerWindow(inheritedProperties);
	document.getElementById("nodeCode").value = inheritedProperties.code || "";
	document.getElementById("nodeFlake").value = inheritedProperties.flake || "";

    } else if (d.type === "grouping_box"){
	
	createInspector(d);
	setupNodeViewerWindow(d);
	document.getElementById("nodeCode").value = d.code || "";
	document.getElementById("nodeFlake").value = d.flake || "";
    } else {
	console.log("F",d)
	createInspector(d);
	loadFromJSON(d.tests);
	setupNodeViewerWindow(d);
	document.getElementById("nodeCode").value = d.code || "";
	document.getElementById("nodeFlake").value = d.flake || "";
    }

    
    inspector.style.display = "block";
    //codeEditor.style.display = "block";

    // Many things rely on this
    currentNode = d;

    setupSections(d.label);

    
    // Create functions for the inspector's link buttons
    const linkToButton = document.getElementById('linkConnectionsToButton');
    linkToButton.onclick = () => {
	connectToNode(d.id);
    };

    const linkFromButton = document.getElementById('linkConnectionsFromButton');
    linkFromButton.onclick = function() {
	connectFromNode(d.id);
    };
    
    
    // Fetch and display connections
    const connectionsToList = document.getElementById("connectionsToList");
    const connectionsFromList = document.getElementById("connectionsFromList");
    const siblingsList = document.getElementById("siblingsList");
    connectionsToList.innerHTML = ''; // Clear existing connections
    connectionsFromList.innerHTML = ''; // Clear existing connections
    siblingsList.innerHTML = ''; // Clear existing connections
    const { connectionsTo, connectionsFrom, flattenedNodes} = await fetchNodeConnections(d.id);
    connectionsTo.forEach(node => {
        const listItem = document.createElement("li");
        
	if (node.x_positions.length > 1) {
            listItem.textContent = `${node.label} [${node.instance}]`;
	} else {
	    listItem.textContent = `${node.label}`;
	}
        
        listItem.style.cursor = "pointer";
	listItem.style.borderBottom = "3px solid "+connectionsToColor(node.connections, transparency=0.5)
        listItem.addEventListener("click", async () => {
	    svg.transition().call(zoom.translateTo, node.x_positions[node.instance], node.y_positions[node.instance]);
	    selectNode(null, node)
        });
        connectionsToList.appendChild(listItem);
    });
    connectionsFrom.forEach(node => {
        const listItem = document.createElement("li");
	if (node.x_positions.length > 1) {
            listItem.textContent = `${node.label} [${node.instance}]`;
	} else {
	    listItem.textContent = `${node.label}`;
	}
        listItem.style.cursor = "pointer";
	listItem.style.borderBottom = "3px solid "+connectionsToColor(node.connections, transparency=0.5)
        listItem.addEventListener("click", async () => {
	    console.log(node.x_positions, node.instance)
	    svg.transition().call(zoom.translateTo, node.x_positions[node.instance], node.y_positions[node.instance]);
	    selectNode(null, node)
        });
        connectionsFromList.appendChild(listItem);
    });
    flattenedNodes.forEach(node => {
        const listItem = document.createElement("li");
	if (node.x_positions.length > 1) {
            listItem.textContent = `${node.label} [${node.instance}]`;
	} else {
	    listItem.textContent = `${node.label}`;
	}
        listItem.style.cursor = "pointer";
	listItem.style.borderBottom = "3px solid "+connectionsToColor(node.connections, transparency=0.5)
        listItem.addEventListener("click", async () => {
	    console.log(node.x_positions, node.instance)
	    if (!node.instance) {
		node.instance = 0;
	    }
	    svg.transition().call(zoom.translateTo, node.x_positions[node.instance], node.y_positions[node.instance]);
	    selectNode(null, node)

        });
        siblingsList.appendChild(listItem);
    });
    
    



    // JS Complitation from nodes
    if (d.label.includes(".js") && event.shiftKey) {
	console.log("EXECUTING CODE", event)



async function generateSourceCode(tree) {
    let sourceCode = '';

    async function traverse(node) {
        let nodeCode = '';

        if (node.code) {
            nodeCode = node.code;
        } else if (node.type === 'inherited') {
            nodeCode = await getInheritedCode(node.id);
        }

        if (nodeCode) {
            sourceCode += `async function ${node.label.replace(/[^a-zA-Z0-9_]/g, '')}(input) {\n`;
            sourceCode += `    ${nodeCode.replace(/\n/g, '\n    ')}\n`;
            sourceCode += `}\n\n`;
        }

        for (const child of node.children) {
            await traverse(child);
        }
    }

    await traverse(tree);
    return sourceCode.trim();
}


    // TODO need to have a different name than main
    // make it work in other functions
    async function generateMainFunction(functionName, tree, ret="return") {
    let mainFunctionCode = `async function ${functionName}(input) {\n`;
    let lastFunctionResult = 'input';  // Initialize to input, in case there are no nodes.

    async function traverse(node, parentResult) {
        const nodeName = node.label.replace(/[^a-zA-Z0-9_]/g, '');
        const functionResult = `${nodeName}Result`;
        mainFunctionCode += `    const ${functionResult} = await ${nodeName}(${parentResult});\n`;
        lastFunctionResult = functionResult;

        for (const child of node.children) {
            await traverse(child, functionResult);
        }
    }

    await traverse(tree, 'input');
    mainFunctionCode += `    return ${lastFunctionResult};\n`; // Add return statement for the last variable
	mainFunctionCode += `}\n\n ${ret} ${functionName}(input=0).catch(console.error);`;
    return mainFunctionCode;
    }
    
        

    const { nodes, links } = await fetchFirstInstanceNodesAndLinks(
    d.x_positions[0] - d.widths[0] / 2,
    d.x_positions[0] + d.widths[0] / 2,
    d.y_positions[0] - d.heights[0] / 2,
    d.y_positions[0] + d.heights[0] / 2
);

console.log("Fetched nodes:", nodes);
console.log("Fetched links:", links);

function findRootNode(nodes, links) {
    const allNodeIds = new Set(nodes.map(node => node.id));
    const targetNodeIds = new Set(links.map(link => link.target));
    const rootNodeIds = [...allNodeIds].filter(id => !targetNodeIds.has(id) && id !== d.id);

    console.log("All Node IDs:", allNodeIds);
    console.log("Target Node IDs:", targetNodeIds);
    console.log("Root Node IDs (excluding d.id):", rootNodeIds);
    
    return nodes.find(node => rootNodeIds.includes(node.id));
}

async function fetchNodeDetails(nodeId, driver) {
    const session = driver.session();
    const query = `
        MATCH (n {id: $nodeId})-[r]->(m)
        RETURN n, r, m
    `;
    const result = await session.run(query, { nodeId });
    session.close();

    if (result.records.length === 0) {
        return { nodes: [], links: [] }; // No connections found
    }

    const nodes = [];
    const links = [];

    result.records.forEach(record => {
        nodes.push(record.get('m').properties);
        links.push({
            source: record.get('n').properties.id,
            target: record.get('m').properties.id
        });
    });

    return { nodes, links };
}

async function buildTree(root, targetNodeIds, driver) {
    const tree = { ...root, children: [] };

    async function traverse(node) {
        const { nodes: nodeDetails, links: nodeLinks } = await fetchNodeDetails(node.id, driver);
        
        const nodeLinksFiltered = nodeLinks.filter(link => targetNodeIds.has(link.target));
        for (const link of nodeLinksFiltered) {
            const childNode = nodeDetails.find(n => n.id === link.target);
            if (childNode) {
                const childTree = { ...childNode, children: [] };
                node.children.push(childTree);
                await traverse(childTree);
            }
        }
    }

    await traverse(tree);
    return tree;
}

    async function setGroupingBoxCode(nodeId, newCode) {
	console.log("setting code", nodeId)
    const session = driver.session();
    try {
        const checkTypeQuery = `
            MATCH (n {id: $nodeId})
            WHERE n.type = 'grouping_box'
            RETURN n
        `;
        const result = await session.run(checkTypeQuery, { nodeId });

        if (result.records.length === 0) {
            return `Node with ID ${nodeId} is not of type "grouping_box" or does not exist.`;
        }

        const updateCodeQuery = `
            MATCH (n {id: $nodeId})
            SET n.code = $newCode
            RETURN n
        `;
        await session.run(updateCodeQuery, { nodeId, newCode });
	
	document.getElementById("nodeCode").value = newCode;
	
        return `Code set for node ${nodeId}.`;
    } catch (error) {
        console.error('Error setting node code:', error);
        return `Error setting node code: ${error.message}`;
    } finally {
        await session.close();
    }
}

const rootNode = findRootNode(nodes, links);
const targetNodeIds = new Set(links.map(link => link.target));
const driver = neo4j.driver('bolt://localhost', neo4j.auth.basic('username', 'password')); // Adjust connection details as necessary
const tree = await buildTree(rootNode, targetNodeIds, driver);

console.log(JSON.stringify(tree, null, 2));

    
const sourceCode = await generateSourceCode(tree);
console.log("Generated Source Code:\n", sourceCode);

const mainFunction = await generateMainFunction(d.label.replaceAll(".js",""), tree, ret="");
console.log("Generated Main Function:\n", mainFunction);

    const evalFullCode = sourceCode + '\n\n' + await generateMainFunction(d.label.replaceAll(".js",""), tree, ret="");
    const saveFullCode = sourceCode + '\n\n' + await generateMainFunction(d.label.replaceAll(".js",""), tree, ret="return");
    console.log("Full Generated Code:\n", evalFullCode);

    console.log("RUNNING CODE")

    await setGroupingBoxCode(nodes[0].id, saveFullCode)
    eval(evalFullCode)
}
    
   
}

// TODO save in settings node
// Function to save the transform to local storage
function saveTransformToLocalStorage(transform) {
    localStorage.setItem('d3-zoom-transform', JSON.stringify(transform));
    //updateConfigNodeProperty("d3-zoom-transform", JSON.stringify(transform))
}

// Function to retrieve the transform from local storage
function getTransformFromLocalStorage() {
    const transform = localStorage.getItem('d3-zoom-transform');
   // const transform = getConfigNodeProperty("d3-zoom-transform")
    return transform ? JSON.parse(transform) : null;
}

let cur_trans = null;

// Initialize zoom
const zoom = d3.zoom()

      .scaleExtent([0.05, 15])
      .on("zoom", (event) => {
          const transform = event.transform;
	  cur_trans = transform;
          g.attr("transform", transform);
          //drawGrid(transform);
          saveTransformToLocalStorage(transform); // Save on zoom
      })
      .on("end", (event) => {
          const transform = event.transform;
	  cur_trans = transform;
          drawNodesAndLinks(transform);
	  drawGrid(transform);
          saveTransformToLocalStorage(transform); // Save on end
      });

// Apply saved transform if it exists
const savedTransform = getTransformFromLocalStorage();
if (savedTransform) {
    svg.call(zoom.transform, d3.zoomIdentity.translate(savedTransform.x, savedTransform.y).scale(savedTransform.k));
}


// Function to handle double-click event
async function handleDoubleClick(event) {
    console.log("DOUBLE CLICK", event.target.localName)
    event.preventDefault();
    event.stopPropagation();
    // Get the mouse coordinates relative to the SVG element
    
    const [x, y] = d3.pointer(event, g.node());

    
    if (event.target.localName === "svg") {
	createOrphanNode(x,y);
    }
    
    if (event.target.localName === "rect" || event.target.localName === "image") {
	
	//console.log("BROH", event.target.__data__.label, g.node())

	const newX = x; // New node's X coordinate
        const newY = y + 30; // New node's Y coordinate
        const userInput = await openSearch('Create a new node with shift+enter or connect to an existing node');
        
        let label = userInput.label;
        let url = "";
        let imageUrl = "";
	
        if (isValidLink(label)) {
            label = await fetchPageTitle(label);
            url = userInput.label;
            // imageUrl = await getFavicon(label);
        }
	
        if (isYouTubeLink(userInput.label)) {
            imageUrl = getYouTubeThumbnail(userInput.label);
            url = userInput.label;
        }
        
        if (label) {
            if (!userInput.exists) {
                await createNodeAndLink(event.target.__data__.id, newX, newY, label, url, imageUrl);
            } else {
                await connectToNode(d.id, label);
            }
            //drawNodesAndLinks(cur_trans);
        }
    }
}




// Attach the double-click event listener to the SVG canvas
svg.on("dblclick", handleDoubleClick);
//nodeLayer.on("dblclick", handleDoubleClick);
//rect.on("dblclick", handleDoubleClick);
// Assuming you have a reference to the SVG element
//const svgElement = document.querySelector('svg');

// Attach the double-click event listener to the SVG element
//window.addEventListener('dblclick', handleDoubleClick);

// Attach the double-click event listener to the window

// Apply the zoom behavior to the SVG element
svg.call(zoom).on("dblclick.zoom", null);




// Initial draw
//drawGrid(d3.zoomIdentity);
//drawNodesAndLinks(d3.zoomIdentity);

// Auto-save for inspector and code editor
const inputs = document.querySelectorAll("#code-editor textarea, #flake-editor textarea, #test-editor table");

inputs.forEach(input => {
    input.addEventListener("input", async (event) => {
        console.log("input");

        const nodeId = currentNode.id;
        
        let propertyName;
	console.log(event)
        switch (event.target.id) {
            case "nodeCode":
                propertyName = "code";
                break;
            case "nodeFlake":
                propertyName = "flake";
                break;
            default:
	        break;
        }

        console.log("UPDATING NODE", nodeId, "PROPERTY", propertyName, "VAL", event.target.value);

        if (currentNode.type !== "inherited" && event.target.localName !== "td") {

            await updateNodeProperty(currentNode.id, propertyName, event.target.value);
        }

	// Update tests
	if (event.target.localName === "td") {
	    const tests = convertTableToJSONString();
	    console.log(tests)
            await updateNodeProperty(currentNode.id, "tests", tests);
	}
    });
});




/*const inputs = document.querySelectorAll("#propertyDiv input, #code-editor textarea, #flake-editor textarea, #test-editor table");
inputs.forEach(input => {
    input.addEventListener("input", async () => {
	console.log("input");
	
        const label = document.getElementById("label").value;
	//const url = document.getElementById("nodeUrl").value;
	//const imageUrl = document.getElementById("nodeImageUrl").value;
        //const x = parseFloat(document.getElementById("nodeX").value);
        //const y = parseFloat(document.getElementById("nodeY").value);
	//const width = parseFloat(document.getElementById("nodeWidth").value);
	//const height = parseFloat(document.getElementById("nodeHeight").value);
	//const instance = parseFloat(document.getElementById("nodeInstance").value);
        //const background = document.getElementById("nodeBackground").value;
	//const type = document.getElementById("nodeType").value;
	//const connectionString = document.getElementById("connectionString").value;
        //const code = document.getElementById("nodeCode").value;
	//const flake = document.getElementById("nodeFlake").value;
	//const tests = convertTableToJSONString();
	
	console.log("UPDATING NODE", document.getElementById("nodeId"));
	if (type === "inherited") {
	    //await updateInheritedNode(id, instance, x, y, width, height);
	} else {
	    await updateNodeProperty(currentNode.id, "label", currentNode.label);
	    
	    //await updateNodeProperties(id, label, url, imageUrl, x, y, width, height, instance, type, connectionString, background, code, flake, tests);
	}
	
        
        const labelElement = nodeLayer.selectAll("text").filter(d => d.id === id)
	      .text(label);
	
        // Update the links connected to the node
        linkLayer.selectAll("line").filter(d => d.source === id || d.target === id)
            .attr("x1", d => nodes.find(n => n.id === d.source).x)
            .attr("y1", d => nodes.find(n => n.id === d.source).y)
            .attr("x2", d => nodes.find(n => n.id === d.target).x)
            .attr("y2", d => nodes.find(n => n.id === d.target).y);
    });
    });
*/
/*async function updateNodeProperty(id, property, value) {
    const session = driver.session();
    
    try {
        const query = `MATCH (n {id: $id})
                       SET n.${property} = $value`;
        const params = { id, value };

        await session.run(query, params);
    } finally {
        await session.close();
    }
}*/



    </script>


<script>
  document.addEventListener('DOMContentLoaded', () => {
      //reset all windows
      loadUIStateFromConfigNode();

      
        const searchInput = document.getElementById('searchInput');
        const searchTitle = document.getElementById('searchTitle');
        const resultsContainer = document.getElementById('results');
        const spotlightSearch = document.getElementById('spotlightSearch');
        let currentIndex = 0;
        let currentResults = [];
        let resolveSearch;

        // Function to open the search interface and return a Promise
        window.openSearch = function(title) {
            return new Promise((resolve) => {
                console.log('Opening search interface'); // Debug log
                resolveSearch = resolve;
                searchTitle.textContent = title;
                spotlightSearch.style.display = 'block';

                searchInput.focus();
            });
        }

        // Function to close the search interface
        function closeSearch() {
            console.log('Closing search interface'); // Debug log
            spotlightSearch.style.display = 'none';
            currentIndex = 0;
            resultsContainer.innerHTML = '';
            searchInput.value = '';
        }

        // Add event listener to close search on pressing Escape
        document.addEventListener('keydown', (event) => {
            if (spotlightSearch.style.display === 'block') {
                if (event.key === 'Escape') {
                    closeSearch();
                    resolveSearch({ label: null, exists: false });
                } else if (event.key === 'ArrowDown') {
                    navigateResults(1);
                } else if (event.key === 'ArrowUp') {
                    navigateResults(-1);
                } else if (event.key === 'Enter') {
                    if (event.shiftKey) {
                        selectInput();
		    } else {
			
  			selectResult(currentIndex, dontZoom=event.altKey);
			
                    }
                }
            }
        });

        // Add event listener to handle input and search
        searchInput.addEventListener('input', (event) => {
            const query = event.target.value;
            if (query) {
                searchNeo4j(query);
            } else {
                resultsContainer.innerHTML = '';
            }
        });

        // Function to perform the search in Neo4j
        async function searchNeo4j(query) {
            //console.log('Searching Neo4j for:', query); // Debug log
            const fuzzyQuery = `(?i).*${query}.*`;
            const session = driver.session();
            try {
                const result = await session.run(
                    `MATCH (n) WHERE n.label =~ $query RETURN n LIMIT 10`,
                    { query: fuzzyQuery }
                );
                const nodes = result.records.flatMap(record => {
                    const node = record.get('n').properties;
                    return node.x_positions.map((x, index) => ({
                        id: node.id,
                        label: node.label,
                        x: node.x_positions[index],
                        y: node.y_positions[index],
			width: node.widths[index],
			height: node.heights[index],
			imageUrl: node.imageUrl,
                        instance: index
                    }));
                });
                currentResults = nodes;
                displayResults(nodes);
            } catch (error) {
                console.error(error);
            } finally {
                await session.close();
            }
        }

        // Function to display search results
        function displayResults(results) {
            //console.log('Displaying results:', results); // Debug log
            resultsContainer.innerHTML = '';
            results.forEach((result, index) => {
                const item = document.createElement('div');
                item.className = 'result-item';
		item.style.display = 'flex';
		item.style.alignItems = 'center';
		
		// Create the HTML content
		let content = '';
		if (result.imageUrl && result.imageUrl !== '') {
		    content += `<img src="${result.imageUrl}" style="width: 50px; height: 50px; margin-right: 10px;"> `;
		}
		content += `<div>${result.label}</div>`;
		
		item.innerHTML = content;
                item.dataset.index = index;
                item.addEventListener('click', () => {
                    selectResult(index);
                });
                resultsContainer.appendChild(item);
            });

	    // highlight the first entry
	    currentIndex = 0;
            updateSelection();
        }

        // Function to navigate results with arrow keys
        function navigateResults(direction) {
            if (currentResults.length > 0) {
                currentIndex = (currentIndex + direction + currentResults.length) % currentResults.length;
                updateSelection();
            }
        }

        // Function to update the selected result
        function updateSelection() {
            const items = resultsContainer.getElementsByClassName('result-item');
            Array.from(items).forEach((item, index) => {
                if (index === currentIndex) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        // Function to select the current result
      function selectResult(index = currentIndex, dontZoom=false) {
            if (index >= 0 && index < currentResults.length) {
                const selectedItem = currentResults[index];
                closeSearch();
                resolveSearch({ label: selectedItem.label, exists: true, id: selectedItem.id, x: selectedItem.x, y: selectedItem.y, instance: selectedItem.instance, dontZoom: dontZoom});
            } else {
                // No results found, return current input
                selectInput(dontZoom=dontZoom);
            }
        }

        // Function to select the current input
        function selectInput(dontZoom=false) {
            const currentInput = searchInput.value;
            if (currentInput) {
                closeSearch();
                resolveSearch({ label: currentInput, exists: false, dontZoom: dontZoom });
            }
        }

        // Function to handle spotlight zoom
        window.spotlightZoom = async function() {
            //console.log('Invoking spotlight zoom'); // Debug log
            const userInput = await openSearch('Search for and zoom to a node on the canvas');
            console.log('User input:', userInput); // Debug log
            if (userInput.exists) {
                const nodeDetails = await fetchNodeById(userInput.id);
                console.log('Node details:', nodeDetails); // Debug log
		
                if (nodeDetails && !userInput.dontZoom) {
		    // nodeDetails.instance is from a forgotten age, just make it 0
                    const selectedPosition_x = nodeDetails.x_positions[0];
                    const selectedPosition_y = nodeDetails.y_positions[0];
		    
		    //const svg = d3.select('svg');
		    //const zoom = d3.zoom();
		    
		    console.log("zooming")
		    svg.transition().call(zoom.translateTo, selectedPosition_x, selectedPosition_y);
		    //svg.transition().call(zoom.translateTo, node.x_positions[node.instance], node.y_positions[node.instance]);		    
		    selectNode(null, nodeDetails)
                }
		
            }
        }

        // Add event listener for keydown to check for Ctrl + Space
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.code === 'Space') {
                event.preventDefault();  // Prevent default action if needed
                console.log('Ctrl + Space pressed'); // Debug log
                window.spotlightZoom();
            }
        });
    });

    </script>




				


    
    
    
</body>
</html>

