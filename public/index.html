<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Grid with D3.js and Neo4j</title>
    <script src="/d3.v6.min.js"></script>
    <script src="/neo4j-driver"></script>
    <style>

html, body {
    height: 100%;
    margin: 0;
    overflow: hidden;
    background-color: #121212;
    color: #e0e0e0;
    font-family: 'Arial', sans-serif;
}

svg {
    width: 100%;
    height: 70%;
    background-color: #1e1e1e;
    cursor: grab;
    border-bottom: 1px solid #333;
}

#inspector {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 250px;
    max-height: 80vh; /* Set max-height to the height of the viewport */
    background: #1e1e1e;
    border: 1px solid #333;
    padding: 15px;
    display: none;
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    overflow: auto; /* Enable scrolling */
}



#inspector h3 {
    margin-top: 0;
    font-size: 18px;
    color: #f0f0f0;
}

#inspector label {
    display: block;
    margin-top: 10px;
    font-size: 14px;
    color: #ccc;
}

#inspector input {
    width: 100%;
    margin-bottom: 10px;
    padding: 5px;
    background: #333;
    border: 1px solid #555;
    color: #e0e0e0;
    border-radius: 4px;
}

#connections {
    margin-top: 10px;
}

   #connections h4 {
            font-size: 16px;
            color: #f0f0f0;
            margin-top: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #connections h4 button {
            background: none;
            border: none;
            color: #f0f0f0;
            font-size: 18px;
            cursor: pointer;
}


#connections ul {
    list-style-type: none;
    padding: 0;
    margin: 0;
}

#connections ul li {
    font-size: 14px;
    color: #ccc;
    cursor: pointer;
    padding: 10px;
    border-bottom: 1px solid #333;
    margin-bottom: 5px;
    border-radius: 4px;
}

#connections ul li:hover {
    color: #fff;
    background-color: #333;
    border-radius: 4px;
}


  .flex-container {
            display: flex;
            width: 100%;
            height: 30%;
        }

        #code-editor, #video-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            border-top: 1px solid #333;
        }

#video-container {
    display: none;
    }

        #code-editor .title-bar, #video-container .title-bar {
            background: #333;
            padding: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #code-editor .title-bar button, #video-container .title-bar button {
            background: none;
            border: none;
            color: #e0e0e0;
            cursor: pointer;
        }

        #code-editor textarea {
            width: 100%;
            height: 100%;
            background: #121212;
            color: #e0e0e0;
            border: none;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            flex-grow: 1;
        }

        #video-container iframe {
            width: 100%;
            height: 100%;
            border: none;
            flex-grow: 1;
        }

        .resizer {
            width: 5px;
            cursor: ew-resize;
            background-color: #333;
        }


.grid-line {
    stroke: #333;
}

 #spotlightSearch {
            display: none;
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: #1e1e1e;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            width: 400px;
            padding: 20px;
            z-index: 1000;
        }
        #searchTitle {
            margin-bottom: 10px;
            font-size: 18px;
        }
        #searchInput {
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            font-size: 16px;
            background-color: #2e2e2e;
            color: #ffffff;
            border: 1px solid #444444;
        }
        #results {
            margin-top: 10px;
        }
        .result-item {
            padding: 10px;
            border-bottom: 1px solid #444444;
            cursor: pointer;
            background-color: #2e2e2e;
            color: #ffffff;
        }
        .result-item:hover, .result-item.selected {
            background-color: #444444;
        }

 .grouping-box {
            fill: purple;
            fill-opacity: 0.3;
            stroke: purple;
            stroke-width: 1px;
            stroke-dasharray: 4;
        }
 .resize-handle {
            fill: white;
            stroke: purple;
            stroke-width: 1px;
            cursor: nwse-resize;
        }
        .selected {
            stroke: red;
        }

    </style>
</head>
<body>
    <svg>
    <defs>
        <marker id="arrowhead" viewBox="0 -5 10 10" refX="10" refY="0" markerWidth="6" markerHeight="6" orient="auto">
            <path d="M0,-5L10,0L0,5" fill="#999" />
        </marker>
    </defs>
    </svg>
    <div id="inspector">
        <h3>Node Inspector</h3>
        <input type="hidden" id="nodeId">
        <label>
            Label:
            <input type="text" id="nodeLabel">
    </label>
    <label>
            Link:
            <input type="text" id="nodeUrl">
    </label>
        <label>
    Image:
            <input type="text" id="nodeImageUrl">
        </label> 

        <label>
            X:
            <input type="number" id="nodeX">
        </label>
        <label>
            Y:
            <input type="number" id="nodeY">
    </label>
    
        <label>
            Width:
            <input type="number" id="nodeWidth">
    </label>
    
        <label>
            Height:
            <input type="number" id="nodeHeight">
    </label>
    
        <label hidden>
            <!--Instance:-->
            <input type="number" id="nodeInstance" hidden>
    </label>
        <label>
            Type:
            <input type="text" id="nodeType">
        </label>
    
        <label hidden>
            <!--Background:-->
            <input type="text" id="nodeBackground" hidden>
        </label>
        <div id="connections">
          <h4>
	    Connections To
            <button id="linkConnectionsToButton">ðŸ”—</button>
	  </h4>
            <ul id="connectionsToList"></ul>
            <h4>
                Connections From
                <button id="linkConnectionsFromButton">ðŸ”—</button>
	    </h4>
    <ul id="connectionsFromList"></ul>
            <h4>
                Other Instances
	    </h4>
    <ul id="siblingsList"></ul>
    
        </div>
    </div>

 
    <div class="flex-container">
        <div id="code-editor">
            <div class="title-bar" id="codeEditorTitleBar">
                <span>Code Editor</span>
                <button onclick="toggleEditor()">_</button>
            </div>
            <textarea id="nodeCode"></textarea>
        </div>
        <div class="resizer" onmousedown="initResize(event)"></div>
        <div id="video-container">
            <div class="title-bar" id="videoTitleBar">
                <span>YouTube Video</span>
                <button onclick="toggleVideo()">_</button>
            </div>
            <iframe id="youtubeVideo" src="https://www.youtube.com/embed/dQw4w9WgXcQ" allowfullscreen></iframe>
        </div>
    </div>

    <div id="spotlightSearch">
        <div id="searchTitle"></div>
        <input type="text" id="searchInput" placeholder="Search...">
        <div id="results"></div>
    </div>
    
    
    <script>
        function toggleEditor() {
            const editor = document.getElementById('code-editor');
            if (editor.style.display === 'none' || editor.style.display === '') {
                editor.style.display = 'flex';
            } else {
                editor.style.display = 'none';
            }
        }

        function toggleVideo() {
            const video = document.getElementById('video-container');
            if (video.style.display === 'none' || video.style.display === '') {
                video.style.display = 'flex';
            } else {
                video.style.display = 'none';
            }
        }

        let startX, startWidth, startFlexGrow;

        function initResize(e) {
            startX = e.clientX;
            const videoContainer = document.getElementById('video-container');
            startWidth = videoContainer.offsetWidth;
            startFlexGrow = parseFloat(window.getComputedStyle(videoContainer).flexGrow);
            document.documentElement.addEventListener('mousemove', doResize, false);
            document.documentElement.addEventListener('mouseup', stopResize, false);
        }

        function doResize(e) {
            const videoContainer = document.getElementById('video-container');
            const codeEditor = document.getElementById('code-editor');
            const deltaX = e.clientX - startX;

            const newFlexGrowVideo = startFlexGrow + deltaX / startWidth;
            const newFlexGrowEditor = 2 - newFlexGrowVideo;

            videoContainer.style.flexGrow = newFlexGrowVideo;
            codeEditor.style.flexGrow = newFlexGrowEditor;
        }

        function stopResize(e) {
            document.documentElement.removeEventListener('mousemove', doResize, false);
            document.documentElement.removeEventListener('mouseup', stopResize, false);
        }


        function setCodeEditorTitle(title) {
            document.getElementById('codeEditorTitleBar').textContent = title;
        }

        function setVideoTitle(title) {
            document.getElementById('videoTitleBar').textContent = title;
        }

        function setVideoUrl(url) {
            const videoId = getYouTubeVideoId(url);
            if (videoId) {
                const embedUrl = `https://www.youtube.com/embed/${videoId}`;
                document.getElementById('youtubeVideo').src = embedUrl;
            } else {
                alert('Invalid YouTube URL');
            }
	    const video = document.getElementById('video-container');
            video.style.display = 'flex';

        }

function getYouTubeThumbnail(url) {
    const videoId = getYouTubeVideoId(url);
    if (videoId) {
	return `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
    }
    return null;
}

        function getYouTubeVideoId(url) {
            const urlObj = new URL(url);
            if (urlObj.hostname === 'www.youtube.com' || urlObj.hostname === 'youtube.com') {
                return urlObj.searchParams.get('v');
            } else if (urlObj.hostname === 'youtu.be') {
                return urlObj.pathname.substring(1);
            }
            return null;
        }

</script>





    <script>
const svg = d3.select("svg");
const g = svg.append("g");

const gridLayer = g.append("g").attr("class", "grid");

const groupingLayer = g.append("g").attr("class", "grouping-layer");

const linkLayer = g.append("g").attr("class", "links");
const inheritedLayer = g.append("g").attr("class", "inherited");
const nodeLayer = g.append("g").attr("class", "nodes");



// GROUPING LAYER
let isDragging = false;
let startPoint = null;
let currentBox = null;

svg.on("mousedown", (event) => {
    if (event.ctrlKey && event.target === svg.node()) {
        event.preventDefault();
        event.stopPropagation();
        isDragging = true;
        startPoint = d3.pointer(event, g.node());
        currentBox = groupingLayer.append("rect")
            .attr("class", "grouping-box")
            .attr("x", startPoint[0])
            .attr("y", startPoint[1])
            .attr("width", 0)
            .attr("height", 0);
    }
});

svg.on("mousemove", (event) => {
    if (isDragging && currentBox) {
        event.preventDefault();
        event.stopPropagation();
        const currentPoint = d3.pointer(event, g.node());
        const width = currentPoint[0] - startPoint[0];
        const height = currentPoint[1] - startPoint[1];
        currentBox
            .attr("width", Math.abs(width))
            .attr("height", Math.abs(height))
            .attr("x", width < 0 ? currentPoint[0] : startPoint[0])
            .attr("y", height < 0 ? currentPoint[1] : startPoint[1]);
    }
});

svg.on("mouseup", (event) => {
    if (isDragging) {
        event.preventDefault();
        event.stopPropagation();
        isDragging = false;
        if (currentBox) {
            const x = +currentBox.attr("x");
            const y = +currentBox.attr("y");
            const width = +currentBox.attr("width");
            const height = +currentBox.attr("height");
            createGroupingBoxNode(x, y, width, height);
            currentBox.remove();
            currentBox = null;
        }
    }
});

svg.on("mouseleave", (event) => {
    if (isDragging) {
        event.preventDefault();
        event.stopPropagation();
        isDragging = false;
        if (currentBox) {
            currentBox.remove(); // Remove incomplete box if mouse leaves the SVG
            currentBox = null;
        }
    }
});




// GROUPING LAYER


const gridSize = 50;

let nodes = []; // Declare nodes as a global variable
let links = []; // Declare links as a global variable

// Initialize Neo4j driver
const driver = neo4j.driver(
    'bolt://localhost:7687', // Replace with your Neo4j instance address
    neo4j.auth.basic('neo4j', 'password') // Replace with your Neo4j username and password
);


async function fetchNodesAndLinks(x0, x1, y0, y1) {
    const session = driver.session();
    const result = await session.run(
        `MATCH (n)
         WHERE any(x IN n.x_positions WHERE x >= $x0 AND x <= $x1)
           AND any(y IN n.y_positions WHERE y >= $y0 AND y <= $y1)
         OPTIONAL MATCH (n)-[r]->(m)
         WHERE any(x IN m.x_positions WHERE x >= $x0 AND x <= $x1)
           AND any(y IN m.y_positions WHERE y >= $y0 AND y <= $y1)
         RETURN n, r, m,
                size((n)--()) AS n_connections,
                size((m)--()) AS m_connections`,
        { x0, x1, y0, y1 }
    );
    session.close();
    nodes = []; // Reset nodes array
    links = []; // Reset links array

    const nodesMap = new Map(); // Use a map to track nodes

    result.records.forEach(record => {
        const nodeN = record.get('n').properties;
        nodeN.x_positions = nodeN.x_positions.map(Number); // Ensure x_positions are numbers
	nodeN.y_positions = nodeN.y_positions.map(Number); // Ensure y_positions are numbers
	nodeN.widths = nodeN.widths.map(Number); // Ensure y_positions are numbers
	nodeN.heights = nodeN.heights.map(Number); // Ensure y_positions are numbers
        nodeN.connections = record.get('n_connections'); // Add connections property

        // Duplicate nodes for each position within the viewport
        nodeN.x_positions.forEach((x, index) => {
            if (x >= x0 && x <= x1 && nodeN.y_positions[index] >= y0 && nodeN.y_positions[index] <= y1) {
                const nodeCopy = { ...nodeN, x: x, y: nodeN.y_positions[index], width: nodeN.widths[index], height: nodeN.heights[index], instance: index };
                nodes.push(nodeCopy);
            }
        });

        const nodeM = record.get('m') ? record.get('m').properties : null;
        if (nodeM) {
            nodeM.x_positions = nodeM.x_positions.map(Number); // Ensure x_positions are numbers
            nodeM.y_positions = nodeM.y_positions.map(Number); // Ensure y_positions are numbers
	    nodeN.widths = nodeN.widths.map(Number); // Ensure y_positions are numbers
	    nodeN.heights = nodeN.heights.map(Number); // Ensure y_positions are numbers
            nodeM.connections = record.get('m_connections'); // Add connections property

            // Duplicate nodes for each position within the viewport
            nodeM.x_positions.forEach((x, index) => {
                if (x >= x0 && x <= x1 && nodeM.y_positions[index] >= y0 && nodeM.y_positions[index] <= y1) {
                    const nodeCopy = { ...nodeM, x: x, y: nodeM.y_positions[index], width: nodeN.widths[index], height: nodeN.heights[index], instance: index };
                    nodes.push(nodeCopy);
                }
            });
        }

        const relationship = record.get('r');
        if (relationship) {
            const source = nodeN.id;
            const target = nodeM ? nodeM.id : null;
            const type = relationship.type; // Get the relationship type
            if (target) {
                links.push({
                    source,
                    target,
                    type
                });
            }
        }
    });

    return { nodes, links };
}

async function fetchNodeById(nodeId) {
    const session = driver.session();
    const result = await session.run(
        `MATCH (n {id: $nodeId})
                 RETURN n`,
        { nodeId }
    );
    session.close();

    if (result.records.length === 0) {
        return null;
    }

    const node = result.records[0].get('n').properties;
    node.x = Number(node.x);
    node.y = Number(node.y);
    return node;
}

// SUPPORTING INHERITANCE
// Merge all inherited node into one node
// Separated Siblings
async function fetchNodeConnections(nodeId) {
    const session = driver.session();

    const getNodeConnections = async (nodeId) => {
        const resultTo = await session.run(
            `MATCH (n {id: $nodeId})-[r]->(m)
             WHERE NOT type(r) = 'INHERITED_FROM'
             RETURN m, size((m)--()) AS m_connections`,
            { nodeId }
        );
        const resultFrom = await session.run(
            `MATCH (n)<-[r]-(m)
             WHERE n.id = $nodeId AND NOT type(r) = 'INHERITED_FROM'
             RETURN m, size((m)--()) AS m_connections`,
            { nodeId }
        );

        const connectionsTo = [];
        const connectionsFrom = [];

        const processRecord = (record, connectionsArray) => {
            const node = record.get('m').properties;
            const xPositions = node.x_positions;
            const yPositions = node.y_positions;
            const widths = node.widths;
            const heights = node.heights;
            const connectionsCount = record.get('m_connections');

            if (Array.isArray(xPositions) && Array.isArray(yPositions) && xPositions.length === yPositions.length) {
                xPositions.forEach((x, index) => {
                    const y = yPositions[index];
                    connectionsArray.push({
                        ...node,
                        x: Number(x),
                        y: Number(y),
                        width: Number(widths[index]),
                        height: Number(heights[index]),
                        instance: index,
                        connections: connectionsCount
                    });
                });
            } else {
                // Handle the case where x_positions and y_positions arrays are missing or lengths do not match
                connectionsArray.push({
                    ...node,
                    x: null,
                    y: null,
                    width: null,
                    height: null,
                    instance: null,
                    connections: connectionsCount
                });
            }
        };

        resultTo.records.forEach(record => processRecord(record, connectionsTo));
        resultFrom.records.forEach(record => processRecord(record, connectionsFrom));

        return { connectionsTo, connectionsFrom };
    };

    const getInheritedNode = async (nodeId) => {
        const inheritedResult = await session.run(
            `MATCH (n {id: $nodeId})-[:INHERITED_FROM]->(m)
             RETURN m.id AS inheritedId, m`,
            { nodeId }
        );

        if (inheritedResult.records.length > 0) {
            const inheritedNode = inheritedResult.records[0].get('m').properties;
            const inheritedNodeId = inheritedResult.records[0].get('inheritedId');
            const inheritedConnections = await getNodeConnections(inheritedNodeId);

            return {
                ...inheritedNode,
                id: inheritedNodeId,
                inheritedConnections
            };
        }

        return null;
    };

    const getInheritors = async (nodeId) => {
        const inheritorsResult = await session.run(
            `MATCH (n)<-[:INHERITED_FROM]-(m)
             WHERE n.id = $nodeId
             RETURN m, size((m)--()) AS m_connections`,
            { nodeId }
        );

        const inheritors = [];
        inheritorsResult.records.forEach(record => {
            const inheritor = record.get('m').properties;
            const connectionsCount = record.get('m_connections');
            inheritors.push({
                ...inheritor,
                connections: connectionsCount
            });
        });

        return inheritors;
    };

    
    const getSiblings = async (nodeId, inheritedNodeId) => {
        const siblingsResult = await session.run(
            `MATCH (s)-[:INHERITED_FROM]->(m)
             WHERE m.id = $inheritedNodeId AND s.id <> $nodeId
             RETURN s, size((s)--()) AS s_connections`,
            { inheritedNodeId, nodeId }
            );

        const siblings = [];
        siblingsResult.records.forEach(record => {
            const sibling = record.get('s').properties;
            const connectionsCount = record.get('s_connections');
            siblings.push({
                ...sibling,
                connections: connectionsCount
            });
        });

        return siblings;
    };

    const mainConnections = await getNodeConnections(nodeId);
    const inheritedNode = await getInheritedNode(nodeId);
    const inheritors = await getInheritors(nodeId);

    let connectionsTo = mainConnections.connectionsTo;
    let connectionsFrom = mainConnections.connectionsFrom;
    let inheritedFrom = [];
    let siblings = [];

    if (inheritedNode) {
        inheritedFrom = [inheritedNode];
        connectionsTo = [...connectionsTo, ...inheritedNode.inheritedConnections.connectionsTo];
        connectionsFrom = [...connectionsFrom, ...inheritedNode.inheritedConnections.connectionsFrom];
        siblings = await getSiblings(nodeId, inheritedNode.id);
    }

    session.close();

    return { connectionsTo, connectionsFrom, flattenedNodes: [...siblings, ...inheritedFrom, ...inheritors] };
}





// Merged Sibling
/*
async function fetchNodeConnections(nodeId) {
    const session = driver.session();

    const getNodeConnections = async (nodeId) => {
        const resultTo = await session.run(
            `MATCH (n {id: $nodeId})-[r]->(m)
             RETURN m, size((m)--()) AS m_connections`,
            { nodeId }
        );
        const resultFrom = await session.run(
            `MATCH (n)<-[r]-(m)
             WHERE n.id = $nodeId
             RETURN m, size((m)--()) AS m_connections`,
            { nodeId }
        );

        const connectionsTo = [];
        const connectionsFrom = [];

        const processRecord = (record, connectionsArray) => {
            const node = record.get('m').properties;
            const xPositions = node.x_positions;
            const yPositions = node.y_positions;
            const widths = node.widths;
            const heights = node.heights;
            const connectionsCount = record.get('m_connections');

            if (Array.isArray(xPositions) && Array.isArray(yPositions) && xPositions.length === yPositions.length) {
                xPositions.forEach((x, index) => {
                    const y = yPositions[index];
                    connectionsArray.push({
                        ...node,
                        x: Number(x),
                        y: Number(y),
                        width: Number(widths[index]),
                        height: Number(heights[index]),
                        instance: index,
                        connections: connectionsCount
                    });
                });
            } else {
                // Handle the case where x_positions and y_positions arrays are missing or lengths do not match
                connectionsArray.push({
                    ...node,
                    x: null,
                    y: null,
                    width: null,
                    height: null,
                    instance: null,
                    connections: connectionsCount
                });
            }
        };

        resultTo.records.forEach(record => processRecord(record, connectionsTo));
        resultFrom.records.forEach(record => processRecord(record, connectionsFrom));

        return { connectionsTo, connectionsFrom };
    };

    const getInheritedNode = async (nodeId) => {
        const inheritedResult = await session.run(
            `MATCH (n {id: $nodeId})-[:INHERITED_FROM]->(m)
             RETURN m.id AS inheritedId, m`,
            { nodeId }
        );

        if (inheritedResult.records.length > 0) {
            const inheritedNode = inheritedResult.records[0].get('m').properties;
            const inheritedNodeId = inheritedResult.records[0].get('inheritedId');
            const inheritedConnections = await getNodeConnections(inheritedNodeId);

            return {
                ...inheritedNode,
                id: nodeId,
                inheritedConnections
            };
        }

        return null;
    };

    const mergeConnections = (primaryConnections, inheritedConnections) => {
        const mergedConnections = [...primaryConnections];
        const existingNodeIds = new Set(primaryConnections.map(conn => conn.id));

        inheritedConnections.forEach(conn => {
            if (!existingNodeIds.has(conn.id)) {
                mergedConnections.push(conn);
                existingNodeIds.add(conn.id);
            }
        });

        return mergedConnections;
    };

    const mainConnections = await getNodeConnections(nodeId);
    const inheritedNode = await getInheritedNode(nodeId);

    let connectionsTo = mainConnections.connectionsTo;
    let connectionsFrom = mainConnections.connectionsFrom;

    if (inheritedNode) {
        connectionsTo = mergeConnections(connectionsTo, inheritedNode.inheritedConnections.connectionsTo);
        connectionsFrom = mergeConnections(connectionsFrom, inheritedNode.inheritedConnections.connectionsFrom);
    }

    session.close();

    return { connectionsTo, connectionsFrom };
}
*/



/*
async function fetchNodeConnections(nodeId) {
    const session = driver.session();

    const resultTo = await session.run(
        `MATCH (n {id: $nodeId})-[r]->(m)
         RETURN m, size((m)--()) AS m_connections`,
        { nodeId }
    );
    const resultFrom = await session.run(
        `MATCH (n)<-[r]-(m)
         WHERE n.id = $nodeId
         RETURN m, size((m)--()) AS m_connections`,
        { nodeId }
    );
    session.close();

    const connectionsTo = [];
    const connectionsFrom = [];

    const processRecord = (record, connectionsArray) => {
        const node = record.get('m').properties;
        const xPositions = node.x_positions;
        const yPositions = node.y_positions;
	const widths = node.widths;
        const height = node.heights;
        const connectionsCount = record.get('m_connections');

        if (Array.isArray(xPositions) && Array.isArray(yPositions) && xPositions.length === yPositions.length) {
            xPositions.forEach((x, index) => {
                const y = yPositions[index];
                connectionsArray.push({
                    ...node,
                    x: Number(x),
                    y: Number(y),
		    width: Number(widths[index]),
		    height: Number(height[index]),
                    instance: index,
                    connections: connectionsCount
                });
            });
        } else {
            // Handle the case where x_positions and y_positions arrays are missing or lengths do not match
            connectionsArray.push({
                ...node,
                x: null,
                y: null,
		width: null,
		height: null,
                instance: null,
                connections: connectionsCount
            });
        }
    };

    resultTo.records.forEach(record => processRecord(record, connectionsTo));
    resultFrom.records.forEach(record => processRecord(record, connectionsFrom));

    return { connectionsTo, connectionsFrom };
}
*/


async function updateNodePosition(id, x, y, instance) {
    const session = driver.session();
    try {
        // Fetch the current x_positions and y_positions arrays
        const result = await session.run(
            `MATCH (n {id: $id})
             RETURN n.x_positions AS x_positions, n.y_positions AS y_positions`,
            { id }
        );

        if (result.records.length > 0) {
            const record = result.records[0];
            const x_positions = record.get('x_positions');
            const y_positions = record.get('y_positions');

            // Update the specific index in the arrays
            x_positions[instance] = x;
            y_positions[instance] = y;

            // Set the updated arrays back to the node
            await session.run(
                `MATCH (n {id: $id})
                 SET n.x_positions = $x_positions, n.y_positions = $y_positions`,
                { id, x_positions, y_positions }
            );
        }
    } finally {
        session.close();
    }
}

async function updateInheritedNode(id, instance, x, y, width, height) {
    const session = driver.session();
    
    try {
        const result = await session.run(
            `MATCH (n {id: $id})
             RETURN n.x_positions AS x_positions, n.y_positions AS y_positions, n.widths AS widths, n.heights AS heights`,
            { id }
        );

        if (result.records.length === 0) {
            throw new Error(`Node with id ${id} not found`);
        }

        const node = result.records[0];
        let x_positions = node.get('x_positions') || [];
        let y_positions = node.get('y_positions') || [];
        let widths = node.get('widths') || [];
        let heights = node.get('heights') || [];

        // Update specific instance index
        x_positions[instance] = x;
        y_positions[instance] = y;
        widths[instance] = width;
        heights[instance] = height;

        await session.run(
            `MATCH (n {id: $id})
             SET n.x_positions = $x_positions, 
                 n.y_positions = $y_positions, 
                 n.widths = $widths, 
                 n.heights = $heights`,
            { 
                id, 
                x_positions, 
                y_positions, 
                widths, 
                heights 
            }
        );
    } finally {
        await session.close();
    }
}


async function updateNodeProperties(id, label, url, imageUrl, x, y, width, height, instance, type, background, code) {
    const session = driver.session();
    
    try {
        const result = await session.run(
            `MATCH (n {id: $id})
             RETURN n.x_positions AS x_positions, n.y_positions AS y_positions, n.widths AS widths, n.heights AS heights`,
            { id }
        );

        if (result.records.length === 0) {
            throw new Error(`Node with id ${id} not found`);
        }

        const node = result.records[0];
        let x_positions = node.get('x_positions') || [];
        let y_positions = node.get('y_positions') || [];
        let widths = node.get('widths') || [];
        let heights = node.get('heights') || [];

        // Update specific instance index
        x_positions[instance] = x;
        y_positions[instance] = y;
        widths[instance] = width;
        heights[instance] = height;



        await session.run(
            `MATCH (n {id: $id})
             SET n.label = $label, 
                 n.url = $url, 
                 n.imageUrl = $imageUrl, 
                 n.x_positions = $x_positions, 
                 n.y_positions = $y_positions, 
                 n.widths = $widths, 
                 n.heights = $heights,
                 n.type = $type, 
                 n.background = $background,
                 n.code = $code`,
            { 
                id, 
                label, 
                url, 
                imageUrl, 
                x_positions, 
                y_positions, 
                widths, 
                heights,
		type,
                background, 
                code 
            }
        );
    } finally {
        await session.close();
    }
}



async function createNodeAndLink(sourceId, x, y, label, url, imageUrl) {
    console.log("CREATED FROM", sourceId)
    const width = 0;
    const height = 0;
    const type = "node";
    const session = driver.session();
    const result = await session.run(
        `MATCH (source {id: $sourceId})
         CREATE (newNode {
             id: randomUUID(),
             x: $x,
             y: $y,
             x_positions: [$x],
             y_positions: [$y],
             widths: [$width],
             heights: [$height],
             type: $type,
             background: 'rgb(255,219,0)',
             label: $label,
             url: $url,
             imageUrl: $imageUrl
         })
         CREATE (source)-[:CONNECTED_TO]->(newNode)
         RETURN newNode`,
        { sourceId, x, y, width, height, type, label, url, imageUrl }
    );
    session.close();
    return result.records[0].get('newNode').properties;
}

/*
  async function createOrphanNode(x, y) {
  const userInput = await openSearch('Create a new orphan node');
  
  let label = userInput.label;
  let url = "";
  let imageUrl = "";
  let width = 0;
  let height = 0;
  
  if (isValidLink(label)) {
  label = await fetchPageTitle(label);
  url = userInput.label;
  // imageUrl = await getFavicon(label);
  }
  
  if (isYouTubeLink(userInput.label)) {
  imageUrl = getYouTubeThumbnail(userInput.label);
  url = userInput.label;
  }
  
  if (label) {
  const session = driver.session();
  
  // Check if the node already exists
  const checkResult = await session.run(
  `MATCH (existingNode {label: $label})
  RETURN existingNode`,
  { label }
  );
  
  if (checkResult.records.length > 0) {
  // Append to existing node's x_positions and y_positions arrays
  const result = await session.run(
  `MATCH (existingNode {label: $label})
  SET existingNode.x_positions = coalesce(existingNode.x_positions, []) + $x,
  existingNode.y_positions = coalesce(existingNode.y_positions, []) + $y
  RETURN existingNode`,
  { label, x, y }
  );
  session.close();
  return result.records[0].get('existingNode').properties;
  } else {
  // Create a new node with x_positions and y_positions arrays
  const result = await session.run(
  `CREATE (newNode {id: randomUUID(), x_positions: [$x], y_positions: [$y], widths: [$width], heights: $[height], background: 'rgb(255,219,0)', label: $label, url: $url, imageUrl: $imageUrl})
  RETURN newNode`,
  { x, y, width, height, label, url, imageUrl }
  );
  session.close();
  return result.records[0].get('newNode').properties;
  }
  
  drawNodesAndLinks(cur_trans);
  }
  }
*/



async function countInheritedFromConnections(labelProperty) {
    console.log(labelProperty)
  // Open a session
  const session = driver.session();

  try {
    // Run a Cypher query to count the connections
    const result = await session.run(
      `
      MATCH (n {label: $labelProperty})<-[:INHERITED_FROM]-(m)
      RETURN count(m) AS connectionCount
      `,
      { labelProperty }
    );

    // Extract the count from the result
    const count = result.records[0].get('connectionCount').toInt();

    return count;
  } catch (error) {
    console.error('Error counting INHERITED_FROM connections:', error);
    throw error;
  } finally {
    // Close the session
    await session.close();
  }
}


async function createOrphanNode(x, y) {
    const userInput = await openSearch('Create a new orphan node');
    
    let label = userInput.label;
    let url = "";
    let imageUrl = "";
    let width = 0;  // Set default width
    let height = 0; // Set default height
    
    if (isValidLink(label)) {
        label = await fetchPageTitle(label);
        url = userInput.label;
        // imageUrl = await getFavicon(label);
    }
    
    if (isYouTubeLink(userInput.label)) {
        imageUrl = getYouTubeThumbnail(userInput.label);
        url = userInput.label;
    }
    
    if (label) {
        const session = driver.session();
        
        // Check if the node already exists
        const checkResult = await session.run(
            `MATCH (existingNode {label: $label})
             RETURN existingNode`,
            { label }
        );
	


        if (checkResult.records.length > 0) {
	    const existing_connections = await countInheritedFromConnections(label)
	    console.log(existing_connections)
            const newLabel = `${label}_${existing_connections}`;
            const type = "inherited"
            // Create a new node with unique x_positions, y_positions, widths, and heights
            const result = await session.run(
                `CREATE (newNode {id: randomUUID(), x_positions: [$x], y_positions: [$y], widths: [$width], heights: [$height], type: $type, label: $newLabel, url: $url, imageUrl: $imageUrl})
                 WITH newNode
                 MATCH (originalNode {label: $label})
                 CREATE (newNode)-[:INHERITED_FROM]->(originalNode)
                 RETURN newNode`,
                { x, y, width, height, newLabel, label, url, imageUrl, type}
            );
            session.close();
            return result.records[0].get('newNode').properties;
        } else {
            const newLabel = `${label}`;
            const type = "node"
            // Create a new node without inheriting since there's no existing node
            const result = await session.run(
                `CREATE (newNode {id: randomUUID(), x_positions: [$x], y_positions: [$y], widths: [$width], heights: [$height], type: $type, background: 'rgb(255,219,0)', label: $newLabel, url: $url, imageUrl: $imageUrl})
                 RETURN newNode`,
                { x, y, width, height, newLabel, url, imageUrl, type }
            );
            session.close();
            return result.records[0].get('newNode').properties;
        }
        
        drawNodesAndLinks(cur_trans);
    }
}











/*
  async function createOrphanNode(x, y) {
  const userInput = await openSearch('Create a new orphan node');
  
  let label = userInput.label;
  let url = "";
  let imageUrl = "";
  let width = 0;  // Set default width
  let height = 0; // Set default height
  
  if (isValidLink(label)) {
  label = await fetchPageTitle(label);
  url = userInput.label;
  // imageUrl = await getFavicon(label);
  }
  
  if (isYouTubeLink(userInput.label)) {
  imageUrl = getYouTubeThumbnail(userInput.label);
  url = userInput.label;
  }
  
  if (label) {
  const session = driver.session();
  
  // Check if the node already exists
  const checkResult = await session.run(
  `MATCH (existingNode {label: $label})
  RETURN existingNode`,
  { label }
  );
  
  if (checkResult.records.length > 0) {
  // Append to existing node's x_positions, y_positions, widths, and heights arrays
  const result = await session.run(
  `MATCH (existingNode {label: $label})
  SET existingNode.x_positions = coalesce(existingNode.x_positions, []) + $x,
  existingNode.y_positions = coalesce(existingNode.y_positions, []) + $y,
  existingNode.widths = coalesce(existingNode.widths, []) + $width,
  existingNode.heights = coalesce(existingNode.heights, []) + $height
  RETURN existingNode`,
  { label, x, y, width, height }
  );
  session.close();
  return result.records[0].get('existingNode').properties;
  } else {
  // Create a new node with x_positions, y_positions, widths, and heights arrays
  const result = await session.run(
  `CREATE (newNode {id: randomUUID(), x_positions: [$x], y_positions: [$y], widths: [$width], heights: [$height], background: 'rgb(255,219,0)', label: $label, url: $url, imageUrl: $imageUrl})
  RETURN newNode`,
  { x, y, width, height, label, url, imageUrl }
  );
  session.close();
  return result.records[0].get('newNode').properties;
  }
  
  drawNodesAndLinks(cur_trans);
  }
  }
*/

async function createGroupingBoxNode(x, y, width, height) {
    const userInput = await openSearch('Create a new grouping box node');
    
    let label = userInput.label;
    let url = "";
    let imageUrl = "";
    
    if (isValidLink(label)) {
        label = await fetchPageTitle(label);
        url = userInput.label;
        // imageUrl = await getFavicon(label);
    }
    
    if (isYouTubeLink(userInput.label)) {
        imageUrl = getYouTubeThumbnail(userInput.label);
        url = userInput.label;
    }
    
    if (label) {
        const session = driver.session();
        
        // Check if the node already exists
        const checkResult = await session.run(
            `MATCH (existingNode {label: $label})
             RETURN existingNode`,
            { label }
        );
        
        if (checkResult.records.length > 0) {
            // Append to existing node's x_positions, y_positions, widths, and heights arrays
            const result = await session.run(
                `MATCH (existingNode {label: $label})
                 SET existingNode.x_positions = coalesce(existingNode.x_positions, []) + $x,
                     existingNode.y_positions = coalesce(existingNode.y_positions, []) + $y,
                     existingNode.widths = coalesce(existingNode.widths, []) + $width,
                     existingNode.heights = coalesce(existingNode.heights, []) + $height
                 RETURN existingNode`,
                { label, x, y, width, height }
            );
            session.close();
            return result.records[0].get('existingNode').properties;
        } else {
            // Create a new node with x_positions, y_positions, widths, heights arrays, and type grouping_box
            const result = await session.run(
                `CREATE (newNode {id: randomUUID(), x_positions: [$x], y_positions: [$y], widths: [$width], heights: [$height], background: 'rgb(255,219,0]', label: $label, url: $url, imageUrl: $imageUrl, type: 'grouping_box'})
                 RETURN newNode`,
                { x, y, width, height, label, url, imageUrl }
            );
            session.close();
            return result.records[0].get('newNode').properties;
        }
        
        drawNodesAndLinks(cur_trans);
    }
}





function drawGrid(transform) {
    cur_trans = transform;
    gridLayer.selectAll(".grid-line").remove(); // Clear existing grid lines

    const width = window.innerWidth;
    const height = window.innerHeight;
    const x0 = -transform.x / transform.k;
    const x1 = (width - transform.x) / transform.k;
    const y0 = -transform.y / transform.k;
    const y1 = (height - transform.y) / transform.k;

    //console.log(`Visible Boundaries: x0=${x0}, x1=${x1}, y0=${y0}, y1=${y1}`);

    const lines = [];

    for (let x = Math.floor(x0 / gridSize) * gridSize; x < x1; x += gridSize) {
        lines.push({ x1: x, y1: y0, x2: x, y2: y1 });
    }
    for (let y = Math.floor(y0 / gridSize) * gridSize; y < y1; y += gridSize) {
        lines.push({ x1: x0, y1: y, x2: x1, y2: y });
    }

    gridLayer.selectAll(".grid-line")
        .data(lines)
        .enter()
        .append("line")
        .attr("class", "grid-line")
        .attr("stroke", "#ddd")
        .attr("stroke-width", 1)
        .attr("x1", d => d.x1)
        .attr("y1", d => d.y1)
        .attr("x2", d => d.x2)
        .attr("y2", d => d.y2);
}

function connectionsToColor(conn, transparency=1.0) {
    connections = Number(conn);
    const colors = [
        { connections: 0, color: [255, 255, 255] }, // White
        { connections: 1, color: [255, 0, 0] },     // Red
        { connections: 4, color: [255, 255, 0] },   // Yellow
        { connections: 7, color: [0, 255, 0] }      // Green
    ];

    // Function to interpolate between two colors
    function interpolateColor(color1, color2, factor) {
        const result = color1.slice();
        for (let i = 0; i < 3; i++) {
            result[i] = Math.round(result[i] + factor * (color2[i] - color1[i]));
        }
        return result;
    }

    // Find the color range the connections value falls into
    let lowerColor = colors[0];
    let upperColor = colors[colors.length - 1];

    for (let i = 0; i < colors.length - 1; i++) {
        if (connections >= colors[i].connections && connections <= colors[i + 1].connections) {
            lowerColor = colors[i];
            upperColor = colors[i + 1];
            break;
        }
    }

    // Calculate the interpolation factor
    const range = upperColor.connections - lowerColor.connections;
    const factor = (connections - lowerColor.connections) / range;

    // Interpolate to get the color
    const color = interpolateColor(lowerColor.color, upperColor.color, factor);
    return `rgb(${color[0]}, ${color[1]}, ${color[2]}, ${transparency})`;
}


async function updateRelationshipType(sourceId, targetId, newType) {
    const session = driver.session();
    await session.run(
        `MATCH (a)-[r]->(b)
         WHERE a.id = $sourceId AND b.id = $targetId
         DELETE r
         CREATE (a)-[newRel:${newType}]->(b)`,
        { sourceId, targetId, newType }
    );
    session.close();
}

async function deleteRelationship(sourceId, targetId) {
    const session = driver.session();
    await session.run(
        `MATCH (a)-[r]->(b)
         WHERE a.id = $sourceId AND b.id = $targetId
         DELETE r`,
        { sourceId, targetId }
    );
    session.close();
}

async function deleteNode(nodeId, instance) {
    const session = driver.session();

    try {
        // Fetch the current x_positions and y_positions arrays
        const result = await session.run(
            'MATCH (n) WHERE n.id = $nodeId RETURN n.x_positions AS x_positions, n.y_positions AS y_positions',
            { nodeId }
        );

        if (result.records.length > 0) {
            const record = result.records[0];
            const x_positions = record.get('x_positions');
            const y_positions = record.get('y_positions');

            if (x_positions.length === 1) {
                // If there is only one position, delete the node and all its relationships
                await session.run(
                    'MATCH (n) WHERE n.id = $nodeId DETACH DELETE n',
                    { nodeId }
                );
                console.log('Node deleted successfully:', nodeId);
            } else {
                // If there are multiple positions, remove the specific position entry
                x_positions.splice(instance, 1);
                y_positions.splice(instance, 1);

                // Update the node with the new positions arrays
                await session.run(
                    'MATCH (n) WHERE n.id = $nodeId SET n.x_positions = $x_positions, n.y_positions = $y_positions',
                    { nodeId, x_positions, y_positions }
                );
                console.log('Position entry deleted successfully for node:', nodeId);
            }
        }
    } catch (error) {
        console.error('Error deleting node or position entry:', error);
        alert('An error occurred while deleting the node or position entry.');
    } finally {
        await session.close();
    }
}



async function createRelationship(sourceId, targetId, type = "CONNECTED_TO") {
    const session = driver.session();
    await session.run(
        `MATCH (a {id: $sourceId}), (b {id: $targetId})
         CREATE (a)-[r:${type}]->(b)
         RETURN r`,
        { sourceId, targetId, type }
    );
    session.close();
}


// V4
function updateLinksAndNodes() {
    // Define arrowhead markers for links
    svg.selectAll("defs").remove(); // Remove existing definitions
    const defs = svg.append("defs");
    defs.append("marker")
        .attr("id", "arrowhead")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 5)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "#999");

    // Function to calculate the new end coordinates for the arrowhead
    function getNewEndCoordinates(sourceX, sourceY, targetX, targetY, radius) {
        const dx = targetX - sourceX;
        const dy = targetY - sourceY;
        const length = Math.sqrt(dx * dx + dy * dy);
        const scale = (length - radius) / length;
        const newTargetX = sourceX + dx * scale;
        const newTargetY = sourceY + dy * scale;
        return { x: newTargetX, y: newTargetY };
    }

    // Helper function to create all possible link instances
    function createLinkData(nodes, links) {
        const newLinks = [];
        links.forEach(link => {
            const sourceNode = nodes.find(n => n.id === link.source);
            const targetNode = nodes.find(n => n.id === link.target);
            sourceNode.x_positions.forEach((_, sourceInstance) => {
                targetNode.x_positions.forEach((_, targetInstance) => {
                    newLinks.push({
                        ...link,
                        sourceInstance,
                        targetInstance
                    });
                });
            });
        });
        return newLinks;
    }

    // Assuming nodes and links are defined somewhere before this
    const updatedLinks = createLinkData(nodes, links);

    // Update links
    const link = linkLayer.selectAll("line").data(updatedLinks, d => `${d.source}-${d.target}-${d.sourceInstance}-${d.targetInstance}`);

    link.exit().remove();

    link.enter()
	.filter(d => d.type !== 'INHERITED_FROM') 
        .append("line")
        .merge(link)
        .attr("stroke", "#999")
        .attr("stroke-width", 2)
        .attr("marker-end", "url(#arrowhead)")
        .attr("x1", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            return sourceNode.x_positions[d.sourceInstance];
        })
        .attr("y1", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            return sourceNode.y_positions[d.sourceInstance];
        })
        .attr("x2", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            const targetNode = nodes.find(n => n.id === d.target);
            const newCoords = getNewEndCoordinates(
                sourceNode.x_positions[d.sourceInstance],
                sourceNode.y_positions[d.sourceInstance],
                targetNode.x_positions[d.targetInstance],
                targetNode.y_positions[d.targetInstance],
                10 // Assuming 10 is the radius of the nodes
            );
            return newCoords.x;
        })
        .attr("y2", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            const targetNode = nodes.find(n => n.id === d.target);
            const newCoords = getNewEndCoordinates(
                sourceNode.x_positions[d.sourceInstance],
                sourceNode.y_positions[d.sourceInstance],
                targetNode.x_positions[d.targetInstance],
                targetNode.y_positions[d.targetInstance],
                10
            );
            return newCoords.y;
        });

    // Update link labels
    const linkLabel = linkLayer.selectAll(".link-label").data(updatedLinks, d => `${d.source}-${d.target}-${d.sourceInstance}-${d.targetInstance}`);

    linkLabel.exit().remove();

    linkLabel.enter()
    	.filter(d => d.type !== 'INHERITED_FROM') 
        .append("text")
        .attr("class", "link-label")
        .merge(linkLabel)
        .attr("x", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            const targetNode = nodes.find(n => n.id === d.target);
            return (sourceNode.x_positions[d.sourceInstance] + targetNode.x_positions[d.targetInstance]) / 2;
        })
        .attr("y", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            const targetNode = nodes.find(n => n.id === d.target);
            return (sourceNode.y_positions[d.sourceInstance] + targetNode.y_positions[d.targetInstance]) / 2;
        })
        .attr("fill", "#eee")
        .attr("font-size", "10px")
        .attr("text-anchor", "middle")
        .attr("dy", -5) // Adjust the position slightly above the link
        .text(d => d.type === "CONNECTED_TO" ? "âœ¦" : d.type)
        .on("dblclick", async function (event, d) {
            const newType = prompt("Enter new relationship type:", d.type);
            if (newType) {
                await updateRelationshipType(d.source, d.target, newType);
                d.type = newType;
                drawGrid(cur_trans);
                drawNodesAndLinks(cur_trans);
            }
        })
        .on("contextmenu", async function (event, d) {
            event.preventDefault();
            const confirmed = confirm("Do you want to delete this interconnection?");
            if (confirmed) {
                await deleteRelationship(d.source, d.target);
                links = links.filter(link => link.source !== d.source || link.target !== d.target);
                drawGrid(cur_trans);
                drawNodesAndLinks(cur_trans);
            }
        });

    // Separate nodes with and without image URLs
    const nodesWithImages = nodes.filter(d => d.imageUrl);
    const nodesWithoutImages = nodes.filter(d => !d.imageUrl);

    function updateNodePositionAndLinks(d) {
        // Update the node's position in the nodes array
        nodes.find(n => n.id === d.id).x_positions[d.instance] = d.x;
        nodes.find(n => n.id === d.id).y_positions[d.instance] = d.y;

        // Update the links connected to the node
        linkLayer.selectAll("line")
            .attr("x1", l => nodes.find(n => n.id === l.source).x_positions[l.sourceInstance])
            .attr("y1", l => nodes.find(n => n.id === l.source).y_positions[l.sourceInstance])
            .attr("x2", l => {
                const sourceNode = nodes.find(n => n.id === l.source);
                const targetNode = nodes.find(n => n.id === l.target);
                const newCoords = getNewEndCoordinates(sourceNode.x_positions[l.sourceInstance], sourceNode.y_positions[l.sourceInstance], targetNode.x_positions[l.targetInstance], targetNode.y_positions[l.targetInstance], 10);
                return newCoords.x;
            })
            .attr("y2", l => {
                const sourceNode = nodes.find(n => n.id === l.source);
                const targetNode = nodes.find(n => n.id === l.target);
                const newCoords = getNewEndCoordinates(sourceNode.x_positions[l.sourceInstance], sourceNode.y_positions[l.sourceInstance], targetNode.x_positions[l.targetInstance], targetNode.y_positions[l.targetInstance], 10);
                return newCoords.y;
            });

        // Update link labels position
        linkLayer.selectAll(".link-label")
            .attr("x", l => {
                const sourceNode = nodes.find(n => n.id === l.source);
                const targetNode = nodes.find(n => n.id === l.target);
                return (sourceNode.x_positions[l.sourceInstance] + targetNode.x_positions[l.targetInstance]) / 2;
            })
            .attr("y", l => {
                const sourceNode = nodes.find(n => n.id === l.source);
                const targetNode = nodes.find(n => n.id === l.target);
                return (sourceNode.y_positions[l.sourceInstance] + targetNode.y_positions[l.targetInstance]) / 2;
            });

        // Update labels position
        nodeLayer.selectAll("text")
            .attr("x", t => t.imageUrl ? t.x_positions[t.instance] + 30 : t.x_positions[t.instance] + 10)
            .attr("y", t => t.imageUrl ? t.y_positions[t.instance] + 10 : t.y_positions[t.instance]);

        // Update circle positions
        nodeLayer.selectAll("rect")
            .attr("cx", n => n.x_positions[n.instance])
            .attr("cy", n => n.y_positions[n.instance]);

        // Update image positions
        nodeLayer.selectAll("image")
            .attr("x", n => n.x_positions[n.instance] - 20)
            .attr("y", n => n.y_positions[n.instance] - 20);
    }

    function findLabel(label, instance) {
	return nodeLayer.selectAll("text")
            .filter(function(d) {
		return d.label === label && d.instance === instance;
            })
            .node(); // returns the first matching element or null if none found
    }
    
    function setupDragBehavior(selection) {
        selection.call(d3.drag()
		       .on("start", function (event, d) {
			   d3.select(this).raise().attr("stroke", "white");
		       })
		       .on("drag", function (event, d) {
			   
			   if (d.x_positions.length >= 1) {
			       d3.select(this).remove();
			       //d3.select(findLabel(d.label, d.instance)).remove();
			   }
			   
			   d.x = event.x;
			   d.y = event.y;
			   
			   // Update the position of the dragged element
			   d3.select(this)
			       .attr("cx", d.x)
			       .attr("cy", d.y)
			       .attr("x", d.x - 20)  // For images
			       .attr("y", d.y - 20); // For images

			   updateNodePositionAndLinks(d);

			   // Update inspector with current position
			   document.getElementById("nodeX").value = d.x;
			   document.getElementById("nodeY").value = d.y;
			   // Center view on the dragged node
			   //svg.transition().duration(0).call(zoom.translateTo, d.x, d.y);
			   //svg.transition()
			   //    .duration(0)
			   //    .call(zoom.transform, d3.zoomIdentity.translate(svgWidth / 2 - d.x, svgHeight / 2 - d.y));
		       })
		       .on("end", async function (event, d) {
			   d3.select(this).attr("stroke", null);
			   await updateNodePosition(d.id, d.x, d.y, d.instance);

			   updateNodePositionAndLinks(d);
			   drawNodesAndLinks(cur_trans);
		       })
		      );
    }
    /*
    // Update circles
    rect = nodeLayer.selectAll("rect").data(nodesWithoutImages, d => d.id);

    rect.exit().remove();

    rect.enter()
    .append("rect")
    .attr("width", d => Number(d.widths[d.instance]) || 20)  // Ensure width is a number, defaults to 20
    .attr("height", d => Number(d.heights[d.instance]) || 20) // Ensure height is a number, defaults to 20
    .attr("x", d => Number(d.x_positions[d.instance]) - (Number(d.widths[d.instance]) / 2 || 10)) // Centering the rectangle
    .attr("y", d => Number(d.y_positions[d.instance]) - (Number(d.heights[d.instance]) / 2 || 10)) // Centering the rectangle
    .attr("rx", d => {
    const width = Number(d.widths[d.instance]) || 20;
    return Math.max(0, (20 - (width - 20) * 0.1)); // Decrease corner radius as width increases
    })
    .attr("ry", d => {
    const height = Number(d.heights[d.instance]) || 20;
    return Math.max(0, (20 - (height - 20) * 0.1)); // Decrease corner radius as height increases
    })
    .merge(rect)
    .attr("label", d => d.label)
    .attr("instance", d => d.instance)
    .attr("cx", d => d.x_positions[d.instance])
    .attr("cy", d => d.y_positions[d.instance])
    .attr("fill", d => {
    if (d.type === "grouping_box") {
    return "rgba(128, 0, 128, 0.1)"; // Partially transparent purple
    } else {
    return connectionsToColor(d.connections) || "red";
    }
    })
    .attr("stroke", d => {
    if (d.type === "grouping_box") {
    return "purple";
    } else {
    return "none"; // Default stroke if not a grouping box
    }
    })
    .attr("stroke-dasharray", d => {
    if (d.type === "grouping_box") {
    return "4 2"; // Dashed line
    } else {
    return "none"; // Default stroke-dasharray if not a grouping box
    }
    })
    .on("mousedown", async function (event, d) {
    selectNode(event, d);
    })
    .call(setupDragBehavior)
    .on("contextmenu", async function (event, d) {
    event.preventDefault();
    const confirmed = confirm("Do you want to delete this node?");
    if (confirmed) {
    await deleteNode(d.id, d.instance);
    
    // Remove the node and its related links from the data
    nodes = nodes.filter(node => node.id !== d.id);
    links = links.filter(link => link.source.id !== d.id && link.target.id !== d.id);
    
    // Redraw the grid and nodes/links
    drawGrid(cur_trans);
    drawNodesAndLinks(cur_trans);
    }
    })
    .on("dblclick", async (event, d) => {
    // Handle double-click event
    });

    // Remove old rects before appending new ones
    rect.exit().remove();
    */
    // Separate the nodes based on their type
    
    //const inheritedNodes = nodesWithoutImages.filter(d => d.type === 'inherited');
    const groupingNodes = nodesWithoutImages.filter(d => d.type === 'grouping_box');
    const inheritedNodes = nodesWithoutImages.filter(d => d.type === 'inherited');
    const regularNodes = nodesWithoutImages.filter(d => d.type !== 'grouping_box' && d.type !== 'inherited');

    

    // Function to update rects
    function updateRects(layer, data, fill, stroke, strokeDasharray) {
	let rect = layer.selectAll("rect").data(data, d => d.id);

	rect.exit().remove();

	rect.enter()
            .append("rect")
            .attr("width", d => Number(d.widths[d.instance]) || 20)  // Ensure width is a number, defaults to 20
            .attr("height", d => Number(d.heights[d.instance]) || 20) // Ensure height is a number, defaults to 20
            .attr("x", d => Number(d.x_positions[d.instance]) - (Number(d.widths[d.instance]) / 2 || 10)) // Centering the rectangle
            .attr("y", d => Number(d.y_positions[d.instance]) - (Number(d.heights[d.instance]) / 2 || 10)) // Centering the rectangle
            .attr("rx", d => {
		const width = Number(d.widths[d.instance]) || 20;
		return Math.max(0, (20 - (width - 20) * 0.1)); // Decrease corner radius as width increases
            })
            .attr("ry", d => {
		const height = Number(d.heights[d.instance]) || 20;
		return Math.max(0, (20 - (height - 20) * 0.1)); // Decrease corner radius as height increases
            })
            .merge(rect)
            .attr("label", d => d.label)
            .attr("instance", d => d.instance)
            .attr("cx", d => d.x_positions[d.instance])
            .attr("cy", d => d.y_positions[d.instance])
            .attr("fill", fill)
            .attr("stroke", stroke)
            .attr("stroke-dasharray", strokeDasharray)
            .on("mousedown", async function (event, d) {
		selectNode(event, d);
            })
            .call(setupDragBehavior)
            .on("contextmenu", async function (event, d) {
		event.preventDefault();
		const confirmed = confirm("Do you want to delete this node?");
		if (confirmed) {
                    await deleteNode(d.id, d.instance);
                    
                    // Remove the node and its related links from the data
                    nodes = nodes.filter(node => node.id !== d.id);
                    links = links.filter(link => link.source.id !== d.id && link.target.id !== d.id);
                    
                    // Redraw the grid and nodes/links
                    drawGrid(cur_trans);
                    drawNodesAndLinks(cur_trans);
		}
            })
            .on("dblclick", async (event, d) => {
		// Handle double-click event
            });
    }

    // Update rects for groupingLayer
    updateRects(groupingLayer, groupingNodes, "rgba(128, 0, 128, 0.1)", "purple", "4 2");
    updateRects(inheritedLayer, inheritedNodes, d => connectionsToColor(d.connections, transparency = 0.5) || "red", d => connectionsToColor(d.connections, transparency = 0.5) || "red", "3 3");

    // Update rects for nodeLayer
    updateRects(nodeLayer, regularNodes, d => connectionsToColor(d.connections) || "red", "none", "none");

    
    // Define a function to get a unique identifier for each rect
    function getUniqueId(d) {
	return d.label + d.instance;
    }    
    // Update images
    const image = nodeLayer.selectAll("image").data(nodesWithImages, d => d.id);

    image.exit().remove();

    image.enter()
        .append("image")
        .attr("width",  d => d.widths[d.instance] || 40)  // Adjust width as needed
        .attr("height",  d => d.heights[d.instance] || 40) // Adjust height as needed
        .attr("x", d => d.x_positions[d.instance] - 20)  // Adjust x position as needed
        .attr("y", d => d.y_positions[d.instance] - 20)  // Adjust y position as needed
        .attr("xlink:href", d => d.imageUrl)
        .on("error", function () {
            d3.select(this).attr("xlink:href", "image-load-failed.png"); // Fallback image if link is bad
	})
        .merge(image)
        .on("mousedown", async function (event, d) {
            selectNode(event, d);
        })
        .call(setupDragBehavior)
        .on("contextmenu", async function (event, d) {
            event.preventDefault();
            const confirmed = confirm("Do you want to delete this node?");
            if (confirmed) {
                await deleteNode(d.id, d.instance);
                
                // Remove the node and its related links from the data
                nodes = nodes.filter(node => node.id !== d.id);
                links = links.filter(link => link.source.id !== d.id && link.target.id !== d.id);
                
                // Redraw the grid and nodes/links
                drawGrid(cur_trans);
                drawNodesAndLinks(cur_trans);
            }
        })
        .on("dblclick", async (event, d) => {
            const newX = d.x + 20; // New node's X coordinate
            const newY = d.y + 20; // New node's Y coordinate
            const userInput = openSearch('Create a new node with shift+enter or connect to an existing node');
            
            let label = userInput.label;
            let url = "";
            let imageUrl = "";

            if (isValidLink(label)) {
                label = await fetchPageTitle(label);
                url = label;
                // imageUrl = await getFavicon(label);
            }

            if (isYouTubeLink(userInput.label)) {
                imageUrl = getYouTubeThumbnail(userInput.label);
                url = userInput.label;
            }
            
            if (label) {
                if (!userInput.exists) {
                    await createNodeAndLink(d.id, newX, newY, label, url, imageUrl);
                } else {
                    await connectToNode(d.id, label);
                }
                drawNodesAndLinks(cur_trans);
            }
        });

    // Update labels
    const labels = nodeLayer.selectAll("text").data(nodes, d => d.id);

    labels.exit().remove();

    labels.enter()
        .append("text")
        .merge(labels)
        .attr("x", d => d.imageUrl ? d.x_positions[d.instance] + 30 : d.x_positions[d.instance] + 10)  // Adjust x position based on node type
        .attr("y", d => d.imageUrl ? d.y_positions[d.instance] + 10 : d.y_positions[d.instance])
        .text(d => d.label)
        .attr("label", d => d.label)
        .attr("instance", d => d.instance)
        .attr("font-size", "12px")
        .attr("fill", "#eee")
}



async function drawNodesAndLinks(transform) {
    const width = window.innerWidth;
    const height = window.innerHeight;
    const x0 = -transform.x / transform.k;
    const x1 = (width - transform.x) / transform.k;
    const y0 = -transform.y / transform.k;
    const y1 = (height - transform.y) / transform.k;

    const { nodes, links } = await fetchNodesAndLinks(x0, x1, y0, y1);

    updateLinksAndNodes();
}


async function fetchPageTitle(url) {
    const proxyUrl = `/proxy?url=${encodeURIComponent(url)}`;

    try {
        const response = await fetch(proxyUrl);
        const text = await response.text();
        console.log('Fetched HTML:', text);  // Log the fetched HTML
        const parser = new DOMParser();
        const doc = parser.parseFromString(text, 'text/html');
        const titleElement = doc.querySelector('title');
        if (titleElement) {
            return titleElement.innerText;
        } else {
            console.warn('No title element found for URL:', url);
            return url;
        }
    } catch (error) {
        console.error("Error fetching title:", error);
        return "Failed to fetch title.";
    }
}

function isValidLink(url) {
    const urlPattern = new RegExp(
        '^(https?:\\/\\/)' + // protocol (required)
            '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.?)+[a-z]{2,}|' + // domain name
            '((\\d{1,3}\\.){3}\\d{1,3})|' + // OR ip (v4) address
            '\\[([a-f\\d]{1,4}:){7,7}[a-f\\d]{1,4}\\]|' + // OR ip (v6) address
            'localhost)' + // OR localhost
            '(\\:\\d+)?' + // port (optional)
            '(\\/[-a-z\\d%_.~+]*)*' + // path (optional)
            '(\\?[;&a-z\\d%_.~+=-]*)?' + // query string (optional)
            '(\\#[-a-z\\d_]*)?$', 'i' // fragment locator (optional)
    );
    return urlPattern.test(url);
}



function isYouTubeLink(url) {
    const youtubeRegex = /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/.+$/;
    return youtubeRegex.test(url);
}


async function connectToNode(nodeId, nodeTo="") {
    let targetLabel;
    let resultExists;
    if (nodeTo === "") {
	// Prompt the user for the label of the node to connect to
	const searchResult = await openSearch('Search for a node to connect to');
	targetLabel = searchResult.label;
	resultExists = searchResult.exists;
    } else {
	targetLabel = nodeTo;
	resultExists = true;
    }
    
    if (targetLabel && resultExists) {
        const session = driver.session();

        try {
            // Find the target node with the specified label
            const result = await session.run(
                'MATCH (targetNode {label: $label}) RETURN targetNode LIMIT 1',
                { label: targetLabel }
            );

            if (result.records.length > 0) {
                const targetNode = result.records[0].get('targetNode');
                const targetNodeId = targetNode.properties.id;

                console.log('Target node found:', targetNode);

                // Create the relationship between the current node and the target node using the id property
                const connectResult = await session.run(
                    'MATCH (n1 {id: $nodeId}), (n2 {id: $targetNodeId}) CREATE (n1)-[:CONNECTED_TO]->(n2) RETURN n1, n2',
                    { nodeId: nodeId, targetNodeId: targetNodeId }
                );

                console.log('Connect result:', connectResult);

                if (connectResult.records.length > 0) {
                    //alert('Nodes connected successfully!');
                } else {
                    alert('Failed to create the connection.');
                }
            } else {
                alert('No node found with the specified label.');
            }
        } catch (error) {
            console.error('Error connecting nodes:', error);
            alert('An error occurred while connecting the nodes.');
        } finally {
            await session.close();
        }
    }
}


async function connectFromNode(nodeId) {
    // Prompt the user for the label of the node to connect from
    const searchResult = await openSearch('Search for the node to connect from');
    sourceLabel = searchResult.label
    
    if (sourceLabel && searchResult.exists) {
        const session = driver.session();

        try {
            // Find the source node with the specified label
            const result = await session.run(
                'MATCH (sourceNode {label: $label}) RETURN sourceNode LIMIT 1',
                { label: sourceLabel }
            );

            if (result.records.length > 0) {
                const sourceNode = result.records[0].get('sourceNode');
                const sourceNodeId = sourceNode.properties.id;

                console.log('Source node found:', sourceNode);

                // Create the relationship between the source node and the current node using the id property
                const connectResult = await session.run(
                    'MATCH (n1 {id: $sourceNodeId}), (n2 {id: $nodeId}) CREATE (n1)-[:CONNECTED_TO]->(n2) RETURN n1, n2',
                    { sourceNodeId: sourceNodeId, nodeId: nodeId }
                );

                console.log('Connect result:', connectResult);

                if (connectResult.records.length > 0) {
                    alert('Nodes connected successfully!');
                } else {
                    alert('Failed to create the connection.');
                }
            } else {
                alert('No node found with the specified label.');
            }
        } catch (error) {
            console.error('Error connecting nodes:', error);
            alert('An error occurred while connecting the nodes.');
        } finally {
            await session.close();
        }
    }
}

// When clicking on a node that's inherited, it should actually get THE CODE of the node it's inherited from
async function getInheritedCode(nodeId) {
    const session = driver.session();
    const query = `
        MATCH (child {id: $nodeId})-[:INHERITED_FROM]->(parent)
        RETURN parent.code AS code
    `;
    const result = await session.run(query, { nodeId });
    if (result.records.length === 0) {
        return null; // No parent or no code property found
    }
    return result.records[0].get('code');
}

function setReadOnlyFields(isReadOnly) {
    document.getElementById("nodeId").readOnly = isReadOnly;
    document.getElementById("nodeLabel").readOnly = isReadOnly;
    document.getElementById("nodeUrl").readOnly = isReadOnly;
    document.getElementById("nodeImageUrl").readOnly = isReadOnly;
    document.getElementById("nodeInstance").readOnly = isReadOnly;
    document.getElementById("nodeBackground").readOnly = isReadOnly;
    document.getElementById("nodeType").readOnly = isReadOnly;
    document.getElementById("nodeCode").readOnly = isReadOnly;
}

async function selectNode(event,d) {
    
    const inspector = document.getElementById("inspector");
    const codeEditor = document.getElementById("code-editor");

    
    inspector.style.display = "block";
    codeEditor.style.display = "block";
    document.getElementById("nodeId").value = d.id;
    document.getElementById("nodeLabel").value = d.label;
    document.getElementById("nodeUrl").value = d.url;
    document.getElementById("nodeImageUrl").value = d.imageUrl;

    
    if (isYouTubeLink(d.url) === true) {
	setVideoUrl(d.url);
	setVideoTitle(d.label);
    } else {
	const video = document.getElementById('video-container');
	video.style.display = 'none';
    }

    setCodeEditorTitle(d.label);
    document.getElementById("nodeX").value = d.x;
    document.getElementById("nodeY").value = d.y;
    document.getElementById("nodeWidth").value = d.width;
    document.getElementById("nodeHeight").value = d.height;
    document.getElementById("nodeInstance").value = d.instance;
    document.getElementById("nodeBackground").value = d.background;
    document.getElementById("nodeType").value = d.type;
    if (d.type === "inherited") {
	document.getElementById("nodeCode").value = await getInheritedCode(d.id) || "";
	setReadOnlyFields(true);
    } else {
	document.getElementById("nodeCode").value = d.code || "";
	setReadOnlyFields(false);

    }

    // Create functions for the inspector's link buttons
    const linkToButton = document.getElementById('linkConnectionsToButton');
    linkToButton.onclick = () => {
	connectToNode(d.id);
    };

    const linkFromButton = document.getElementById('linkConnectionsFromButton');
    linkFromButton.onclick = function() {
	connectFromNode(d.id);
    };
    
    
    // Fetch and display connections
    const connectionsToList = document.getElementById("connectionsToList");
    const connectionsFromList = document.getElementById("connectionsFromList");
    const siblingsList = document.getElementById("siblingsList");
    connectionsToList.innerHTML = ''; // Clear existing connections
    connectionsFromList.innerHTML = ''; // Clear existing connections
    siblingsList.innerHTML = ''; // Clear existing connections
    const { connectionsTo, connectionsFrom, flattenedNodes} = await fetchNodeConnections(d.id);
    connectionsTo.forEach(node => {
        const listItem = document.createElement("li");
        
	if (node.x_positions.length > 1) {
            listItem.textContent = `${node.label} [${node.instance}]`;
	} else {
	    listItem.textContent = `${node.label}`;
	}
        
        listItem.style.cursor = "pointer";
	listItem.style.borderBottom = "3px solid "+connectionsToColor(node.connections, transparency=0.5)
        listItem.addEventListener("click", async () => {
	    svg.transition().call(zoom.translateTo, node.x_positions[node.instance], node.y_positions[node.instance]);
        });
        connectionsToList.appendChild(listItem);
    });
    connectionsFrom.forEach(node => {
        const listItem = document.createElement("li");
	if (node.x_positions.length > 1) {
            listItem.textContent = `${node.label} [${node.instance}]`;
	} else {
	    listItem.textContent = `${node.label}`;
	}
        listItem.style.cursor = "pointer";
	listItem.style.borderBottom = "3px solid "+connectionsToColor(node.connections, transparency=0.5)
        listItem.addEventListener("click", async () => {
	    console.log(node.x_positions, node.instance)
	    svg.transition().call(zoom.translateTo, node.x_positions[node.instance], node.y_positions[node.instance]);
	    /*                    const nodeDetails = await fetchNodeById(node.id);
				  console.log("YO", node, nodeDetails)
				  if (nodeDetails) {
				  selectNode(nodeDetails);
				  const transform = d3.zoomTransform(svg.node());
				  console.log("F", nodeDetails.x_positions[nodeDetails.instance])
				  svg.transition().call(zoom.translateTo, node.x_positions[node.instance], node.y_positions[node.instance]);
				  }*/
        });
        connectionsFromList.appendChild(listItem);
    });
    flattenedNodes.forEach(node => {
        const listItem = document.createElement("li");
	if (node.x_positions.length > 1) {
            listItem.textContent = `${node.label} [${node.instance}]`;
	} else {
	    listItem.textContent = `${node.label}`;
	}
        listItem.style.cursor = "pointer";
	listItem.style.borderBottom = "3px solid "+connectionsToColor(node.connections, transparency=0.5)
        listItem.addEventListener("click", async () => {
	    console.log(node.x_positions, node.instance)
	    if (!node.instance) {
		node.instance = 0;
	    }
	    svg.transition().call(zoom.translateTo, node.x_positions[node.instance], node.y_positions[node.instance]);
	    /*                    const nodeDetails = await fetchNodeById(node.id);
				  console.log("YO", node, nodeDetails)
				  if (nodeDetails) {
				  selectNode(nodeDetails);
				  const transform = d3.zoomTransform(svg.node());
				  console.log("F", nodeDetails.x_positions[nodeDetails.instance])
				  svg.transition().call(zoom.translateTo, node.x_positions[node.instance], node.y_positions[node.instance]);
				  }*/
        });
        siblingsList.appendChild(listItem);
    });
    
    
    /*    if (d.label.includes(".js") && event.shiftKey) {

	  console.log("BBBBRRRU", event);



	  async function getNodesAndRelationships(d) {
	  const session = driver.session();

	  try {
	  // Query to get grouping box parameters from any node with type `grouping_box`
	  const groupingBoxResult = await session.run(`
	  MATCH (box {type: 'grouping_box'})
	  RETURN box.x_positions AS x_positions, box.y_positions AS y_positions, box.widths AS widths, box.heights AS heights
	  `);

	  const { x_positions, y_positions, widths, heights } = groupingBoxResult.records[0].toObject();

	  // Function to check if a point is within a box, considering the box is positioned by its center
	  function isInBox(x, y, xCenter, yCenter, width, height) {
	  const xMin = xCenter - width / 2;
	  const xMax = xCenter + width / 2;
	  const yMin = yCenter - height / 2;
	  const yMax = yCenter + height / 2;
	  return x >= xMin && x <= xMax && y >= yMin && y <= yMax;
	  }

	  // Find all grouping boxes that contain at least one instance of node `d`
	  const groupingBoxIndices = [];
	  for (let i = 0; i < x_positions.length; i++) {
	  for (let j = 0; j < d.x_positions.length; j++) {
	  if (isInBox(d.x_positions[j], d.y_positions[j], x_positions[i], y_positions[i], widths[i], heights[i])) {
	  groupingBoxIndices.push({boxIndex: i, instanceIndex: j});
	  }
	  }
	  }

	  if (groupingBoxIndices.length === 0) {
	  console.log(`Node d coordinates: (${d.x_positions}, ${d.y_positions})`);
	  console.log('Grouping Boxes:');
	  for (let i = 0; i < x_positions.length; i++) {
	  console.log(`Box ${i}: x=${x_positions[i]}, y=${y_positions[i]}, width=${widths[i]}, height=${heights[i]}`);
	  }
	  throw new Error("Node `d` is not within any grouping box.");
	  }

	  // Function to get nodes and relationships for a specific grouping box index
	  async function getNodesAndRelationshipsForBox(groupingBoxIndex, instanceIndex, instanceLabel) {
	  const result = await session.run(`
          MATCH (startNode {label: "${d.label}"})
          WITH startNode
          MATCH p = (startNode)-[:CONNECTED_TO*]->(node)
          WHERE node.label ENDS WITH '.js'
          AND any(pos in node.x_positions WHERE pos >= ${x_positions[groupingBoxIndex]} - ${widths[groupingBoxIndex] / 2} AND pos <= ${x_positions[groupingBoxIndex]} + ${widths[groupingBoxIndex] / 2})
          AND any(pos in node.y_positions WHERE pos >= ${y_positions[groupingBoxIndex]} - ${heights[groupingBoxIndex] / 2} AND pos <= ${y_positions[groupingBoxIndex]} + ${heights[groupingBoxIndex] / 2})
          AND all(n in nodes(p) WHERE 
          any(pos in n.x_positions WHERE pos >= ${x_positions[groupingBoxIndex]} - ${widths[groupingBoxIndex] / 2} AND pos <= ${x_positions[groupingBoxIndex]} + ${widths[groupingBoxIndex] / 2})
          AND any(pos in n.y_positions WHERE pos >= ${y_positions[groupingBoxIndex]} - ${heights[groupingBoxIndex] / 2} AND pos <= ${y_positions[groupingBoxIndex]} + ${heights[groupingBoxIndex] / 2})
          )
          RETURN DISTINCT startNode, p
	  `);

	  const nodes = new Map();
	  const relationships = new Set();

	  result.records.forEach(record => {
	  const startNode = record.get('startNode').properties;
	  const path = record.get('p');

	  const instanceStartNode = { ...startNode, label: instanceLabel };
	  if (!nodes.has(instanceStartNode.label)) {
	  nodes.set(instanceStartNode.label, instanceStartNode);
	  }

	  path.segments.forEach(segment => {
	  const start = segment.start.properties;
	  const end = segment.end.properties;

	  const instanceStart = { ...start, label: `${start.label}` };
	  const instanceEnd = { ...end, label: `${end.label}` };

	  if (!nodes.has(instanceStart.label)) {
	  nodes.set(instanceStart.label, instanceStart);
	  }

	  if (!nodes.has(instanceEnd.label)) {
	  nodes.set(instanceEnd.label, instanceEnd);
	  }

	  relationships.add(JSON.stringify({ from: instanceStart.label, to: instanceEnd.label }));
	  });
	  });

	  return { nodes: Array.from(nodes.values()), relationships: Array.from(relationships).map(rel => JSON.parse(rel)) };
	  }

	  // Collect results for all relevant grouping boxes and instances
	  const results = [];
	  for (let i = 0; i < groupingBoxIndices.length; i++) {
	  const {boxIndex, instanceIndex} = groupingBoxIndices[i];
	  const instanceLabel = instanceIndex === 0 ? `${d.label}` : `${d.label.split('.js')[0]}_${instanceIndex}.js`;
	  const result = await getNodesAndRelationshipsForBox(boxIndex, instanceIndex, instanceLabel);
	  results.push(result);
	  }

	  // Merge results without combining instances
	  const mergedNodes = [];
	  const mergedRelationships = [];

	  results.forEach(result => {
	  mergedNodes.push(...result.nodes);
	  mergedRelationships.push(...result.relationships);
	  });

	  return { nodes: mergedNodes, relationships: mergedRelationships };
	  } finally {
	  await session.close();
	  }
	  }

	  
	  
	  

	  




	  

	  function createFunctionCode(nodes, relationships) {
	  const functionCalls = {};

	  relationships.forEach(rel => {
	  const from = rel.from.replace('.js', '');
	  const to = rel.to.replace('.js', '');

	  if (!functionCalls[from]) {
	  functionCalls[from] = [];
	  }

	  functionCalls[from].push(to);
	  });

	  return nodes.map(node => {
	  const functionName = node.label.replace('.js', '');
	  const code = node.code || '';
	  const calls = functionCalls[functionName] || [];
	  
	  // Generate callCode based on relationships for all functions, with null check
	  const callCode = calls.map(call => `  if (output !== null) {\n    ${call}(output);\n  }`).join('\n');

	  // Default output value
	  const defaultOutput = `null`;
	  
	  return `function ${functionName}(input = "") {\n  let output = ${defaultOutput};\n  ${code}\n${callCode}\n}`;
	  }).join('\n\n');
	  }

	  async function executeFunctionCode(d) {
	  const { nodes, relationships } = await getNodesAndRelationships(d);
	  
	  if (nodes.length === 0 || relationships.length === 0) {
	  // No nodes or relationships found, just eval the current code
	  eval(d.code);
	  } else {
	  // Generate and eval the function code
	  const functionsCode = createFunctionCode(nodes, relationships) + `\n${d.label.replace(".js","")}();`;
	  console.log(functionsCode);
	  eval(functionsCode);
	  }
	  }

	  // Execute the function with the given 'd' object
	  executeFunctionCode(d);

	  
	  }*/

    console.log("EXECUTING CODE")



    

    if (d.label.includes(".js") && event.shiftKey) {
	console.log("BBBBRRRU", event);
	/*
	  async function getNodesAndRelationships(d) {
          const session = driver.session();

          try {
          // Query to get grouping box parameters from any node with type `grouping_box`
          const groupingBoxResult = await session.run(`
          MATCH (box {type: 'grouping_box'})
          RETURN box.x_positions AS x_positions, box.y_positions AS y_positions, box.widths AS widths, box.heights AS heights
          `);

          const { x_positions, y_positions, widths, heights } = groupingBoxResult.records[0].toObject();

          // Function to check if a point is within a box, considering the box is positioned by its center
          function isInBox(x, y, xCenter, yCenter, width, height) {
          const xMin = xCenter - width / 2;
          const xMax = xCenter + width / 2;
          const yMin = yCenter - height / 2;
          const yMax = yCenter + height / 2;
          return x >= xMin && x <= xMax && y >= yMin && y <= yMax;
          }

	  
          // Find all grouping boxes that contain at least one instance of node `d`
          const groupingBoxIndices = [];
          for (let i = 0; i < x_positions.length; i++) {
          for (let j = 0; j < d.x_positions.length; j++) {
          if (isInBox(d.x_positions[j], d.y_positions[j], x_positions[i], y_positions[i], widths[i], heights[i])) {
          groupingBoxIndices.push({boxIndex: i, instanceIndex: j});
          }
          }
          }

          if (groupingBoxIndices.length === 0) {
          console.log(`Node d coordinates: (${d.x_positions}, ${d.y_positions})`);
          console.log('Grouping Boxes:');
          for (let i = 0; i < x_positions.length; i++) {
          console.log(`Box ${i}: x=${x_positions[i]}, y=${y_positions[i]}, width=${widths[i]}, height=${heights[i]}`);
          }
          throw new Error("Node `d` is not within any grouping box.");
          }

          // Function to get nodes and relationships for a specific grouping box index
          async function getNodesAndRelationshipsForBox(groupingBoxIndex, instanceIndex, instanceLabel) {
          const result = await session.run(`
          MATCH (startNode {label: "${d.label}"})
          WITH startNode
          MATCH p = (startNode)-[:CONNECTED_TO*]->(node)
          WHERE node.label ENDS WITH '.js'
          AND any(pos in node.x_positions WHERE pos >= ${x_positions[groupingBoxIndex]} - ${widths[groupingBoxIndex] / 2} AND pos <= ${x_positions[groupingBoxIndex]} + ${widths[groupingBoxIndex] / 2})
          AND any(pos in node.y_positions WHERE pos >= ${y_positions[groupingBoxIndex]} - ${heights[groupingBoxIndex] / 2} AND pos <= ${y_positions[groupingBoxIndex]} + ${heights[groupingBoxIndex] / 2})
          AND all(n in nodes(p) WHERE 
          any(pos in n.x_positions WHERE pos >= ${x_positions[groupingBoxIndex]} - ${widths[groupingBoxIndex] / 2} AND pos <= ${x_positions[groupingBoxIndex]} + ${widths[groupingBoxIndex] / 2})
          AND any(pos in n.y_positions WHERE pos >= ${y_positions[groupingBoxIndex]} - ${heights[groupingBoxIndex] / 2} AND pos <= ${y_positions[groupingBoxIndex]} + ${heights[groupingBoxIndex] / 2})
          )
          RETURN DISTINCT startNode, p
          `);

          const nodes = new Map();
          const relationships = new Set();

          result.records.forEach(record => {
          const startNode = record.get('startNode').properties;
          const path = record.get('p');

          const instanceStartNode = { ...startNode, label: instanceLabel };
          if (!nodes.has(instanceStartNode.label)) {
          nodes.set(instanceStartNode.label, instanceStartNode);
          }

          path.segments.forEach(segment => {
          const start = segment.start.properties;
          const end = segment.end.properties;

          const instanceStart = { ...start, label: `${start.label}` };
          const instanceEnd = { ...end, label: `${end.label}` };

          if (!nodes.has(instanceStart.label)) {
          nodes.set(instanceStart.label, instanceStart);
          }

          if (!nodes.has(instanceEnd.label)) {
          nodes.set(instanceEnd.label, instanceEnd);
          }

          relationships.add(JSON.stringify({ from: instanceStart.label, to: instanceEnd.label }));
          });
          });

          return { nodes: Array.from(nodes.values()), relationships: Array.from(relationships).map(rel => JSON.parse(rel)) };
          }

          // Collect results for all relevant grouping boxes and instances
          const results = [];
          for (let i = 0; i < groupingBoxIndices.length; i++) {
          const {boxIndex, instanceIndex} = groupingBoxIndices[i];
          const instanceLabel = instanceIndex === 0 ? `${d.label}` : `${d.label.split('.js')[0]}_${instanceIndex}.js`;
          const result = await getNodesAndRelationshipsForBox(boxIndex, instanceIndex, instanceLabel);
          results.push(result);
          }

          // Merge results without combining instances
          const mergedNodes = [];
          const mergedRelationships = [];

          results.forEach(result => {
          mergedNodes.push(...result.nodes);
          mergedRelationships.push(...result.relationships);
          });

          return { nodes: mergedNodes, relationships: mergedRelationships };
          } finally {
          await session.close();
          }
	  }
	*/


	async function getNodesAndRelationships(d) {
	    const session = driver.session();

	    try {
		// Query to get all grouping box nodes
		const groupingBoxResult = await session.run(`
            MATCH (box {type: 'grouping_box'})
            RETURN box.x_positions AS x_positions, box.y_positions AS y_positions, box.widths AS widths, box.heights AS heights
        `);

		if (groupingBoxResult.records.length === 0) {
		    throw new Error("No grouping boxes found.");
		}

		const boxes = groupingBoxResult.records.map(record => record.toObject());

		// Function to check if a point is within a box, considering the box is positioned by its center
		function isInBox(x, y, xCenter, yCenter, width, height) {
		    const xMin = Number(xCenter) - Number(width) / 2;
		    const xMax = Number(xCenter) + Number(width) / 2;
		    const yMin = Number(yCenter) - Number(height) / 2;
		    const yMax = Number(yCenter) + Number(height) / 2;
		    

		    console.log(`Checking point (${x}, ${y}) within box centered at (${xCenter}, ${yCenter}) with width ${width} and height ${height}`);
		    console.log(`Box boundaries: xMin=${xMin}, xMax=${xMax}, yMin=${yMin}, yMax=${yMax}`);

		    const withinX = x >= xMin && x <= xMax;
		    const withinY = y >= yMin && y <= yMax;

		    console.log(`withinX: ${withinX}, withinY: ${withinY}`);

		    return withinX && withinY;
		}

		// Find all grouping boxes that contain at least one instance of node `d`
		const groupingBoxIndices = [];
		boxes.forEach((box, boxIndex) => {
		    for (let j = 0; j < d.x_positions.length; j++) {
			console.log(`Checking if d (${d.x_positions[j]}, ${d.y_positions[j]}) is in box ${boxIndex}: (${box.x_positions}, ${box.y_positions}, ${box.widths}, ${box.heights})`);
			if (isInBox(d.x_positions[j], d.y_positions[j], box.x_positions, box.y_positions, box.widths, box.heights)) {
			    console.log(`d is in box ${boxIndex}`);
			    groupingBoxIndices.push({boxIndex, instanceIndex: j});
			}
		    }
		});

		if (groupingBoxIndices.length === 0) {
		    console.log(`Node d coordinates: (${d.x_positions}, ${d.y_positions})`);
		    console.log('Grouping Boxes:');
		    boxes.forEach((box, i) => {
			console.log(`Box ${i}: x=${box.x_positions}, y=${box.y_positions}, width=${box.widths}, height=${box.heights}`);
		    });
		    throw new Error("Node `d` is not within any grouping box.");
		}

		// Function to get nodes and relationships for a specific grouping box index
		async function getNodesAndRelationshipsForBox(box, instanceIndex, instanceLabel) {
		    const result = await session.run(`
                MATCH (startNode {label: "${d.label}"})
                WITH startNode
                MATCH p = (startNode)-[:CONNECTED_TO*]->(node)
                WHERE node.label ENDS WITH '.js'
                  AND any(pos in node.x_positions WHERE pos >= ${box.x_positions} - ${box.widths / 2} AND pos <= ${box.x_positions} + ${box.widths / 2})
                  AND any(pos in node.y_positions WHERE pos >= ${box.y_positions} - ${box.heights / 2} AND pos <= ${box.y_positions} + ${box.heights / 2})
                  AND all(n in nodes(p) WHERE 
                    any(pos in n.x_positions WHERE pos >= ${box.x_positions} - ${box.widths / 2} AND pos <= ${box.x_positions} + ${box.widths / 2})
                    AND any(pos in n.y_positions WHERE pos >= ${box.y_positions} - ${box.heights / 2} AND pos <= ${box.y_positions} + ${box.heights / 2})
                  )
                RETURN DISTINCT startNode, p
            `);

		    const nodes = new Map();
		    const relationships = new Set();

		    result.records.forEach(record => {
			const startNode = record.get('startNode').properties;
			const path = record.get('p');

			const instanceStartNode = { ...startNode, label: instanceLabel };
			if (!nodes.has(instanceStartNode.label)) {
			    nodes.set(instanceStartNode.label, instanceStartNode);
			}

			path.segments.forEach(segment => {
			    const start = segment.start.properties;
			    const end = segment.end.properties;

			    const instanceStart = { ...start, label: `${start.label}` };
			    const instanceEnd = { ...end, label: `${end.label}` };

			    if (!nodes.has(instanceStart.label)) {
				nodes.set(instanceStart.label, instanceStart);
			    }

			    if (!nodes.has(instanceEnd.label)) {
				nodes.set(instanceEnd.label, instanceEnd);
			    }

			    relationships.add(JSON.stringify({ from: instanceStart.label, to: instanceEnd.label }));
			});
		    });

		    return { nodes: Array.from(nodes.values()), relationships: Array.from(relationships).map(rel => JSON.parse(rel)) };
		}

		// Collect results for all relevant grouping boxes and instances
		const results = [];
		for (let i = 0; i < groupingBoxIndices.length; i++) {
		    const {boxIndex, instanceIndex} = groupingBoxIndices[i];
		    //console.log(d.la
		    const instanceLabel = d.label //instanceIndex === 0 ? `${d.label}` : `${d.label.split('.js')[0]}_${instanceIndex}.js`;
		    const result = await getNodesAndRelationshipsForBox(boxes[boxIndex], instanceIndex, instanceLabel);
		    results.push(result);
		}

		// Merge results without combining instances
		const mergedNodes = [];
		const mergedRelationships = [];

		results.forEach(result => {
		    mergedNodes.push(...result.nodes);
		    mergedRelationships.push(...result.relationships);
		});

		return { nodes: mergedNodes, relationships: mergedRelationships };
	    } finally {
		await session.close();
	    }
	}

	


	

	

	async function createFunctionCode(nodes, relationships) {
            const functionCalls = {};

            relationships.forEach(rel => {
		const from = rel.from.replace('.js', '');
		const to = rel.to.replace('.js', '');

		if (!functionCalls[from]) {
                    functionCalls[from] = [];
		}

		functionCalls[from].push(to);
            });

            /*const functionDefinitions = nodes.map(node => {
		const functionName = node.label.replace('.js', '');
		let code = ""
		if (node.type === "inherited") {
		    code = await getInheritedCode(node.id) || '';
		} else {
		    code = node.code || '';
		}
		return `async function ${functionName}(input) {\n${code}\n}`;
            }).join('\n\n');
	    */

	    const functionDefinitions = await Promise.all(nodes.map(async node => {
		const functionName = node.label.replace('.js', '');
		let code = "";
		if (node.type === "inherited") {
		    code = await getInheritedCode(node.id) || '';
		} else {
		    code = node.code || '';
		}
		return `async function ${functionName}(input) {\n${code}\n}`;
	    }));



	    const functionCallsCode = [];
	    functionCallsCode.push(`(async function main() {`);
	    let isFirstFunction = true;

	    Object.keys(functionCalls).forEach((functionName) => {
		if (isFirstFunction) {
		    functionCallsCode.push(`const var_${functionName} = await ${functionName}();`);
		    functionCalls[functionName].forEach((call) => {
			functionCallsCode.push(`const var_${call} = await ${call}(var_${functionName});`);
		    });
		    isFirstFunction = false;
		} else {
		    functionCalls[functionName].forEach((call) => {
			functionCallsCode.push(`const var_${call} = await ${call}(var_${functionName});`);
		    });
		}
	    });

	    functionCallsCode.push(`})();`);

	    
	    

            return `${functionDefinitions.join('\n\n')}\n\n${functionCallsCode.join('\n')}`;
	}

	async function executeFunctionCode(d) {
            const { nodes, relationships } = await getNodesAndRelationships(d);
	    
            
            if (nodes.length === 0 || relationships.length === 0) {
		// No nodes or relationships found, just eval the current code
		//console.log("1",d.code)
		//eval(d.code);
		alert("no relationships found")
            } else {
		// Generate and eval the function code
		const functionsCode = await createFunctionCode(nodes, relationships);
		console.log(functionsCode);
		eval(functionsCode);
            }
	}

	// Execute the function with the given 'd' object
	executeFunctionCode(d);
    }
    
    

}


// Function to save the transform to local storage
function saveTransformToLocalStorage(transform) {
    localStorage.setItem('d3-zoom-transform', JSON.stringify(transform));
}

// Function to retrieve the transform from local storage
function getTransformFromLocalStorage() {
    const transform = localStorage.getItem('d3-zoom-transform');
    return transform ? JSON.parse(transform) : null;
}

let cur_trans = null;

// Initialize zoom
const zoom = d3.zoom()

      .scaleExtent([0.05, 6])
      .on("zoom", (event) => {
          const transform = event.transform;
	  cur_trans = transform;
          g.attr("transform", transform);
          drawGrid(transform);
          saveTransformToLocalStorage(transform); // Save on zoom
      })
      .on("end", (event) => {
          const transform = event.transform;
	  cur_trans = transform;
          drawNodesAndLinks(transform);
          saveTransformToLocalStorage(transform); // Save on end
      });

// Apply saved transform if it exists
const savedTransform = getTransformFromLocalStorage();
if (savedTransform) {
    svg.call(zoom.transform, d3.zoomIdentity.translate(savedTransform.x, savedTransform.y).scale(savedTransform.k));
}


// Function to handle double-click event
async function handleDoubleClick(event) {
    event.preventDefault();
    event.stopPropagation();
    // Get the mouse coordinates relative to the SVG element
    
    const [x, y] = d3.pointer(event, g.node());

    
    if (event.target.localName === "svg") {
	createOrphanNode(x,y);
    }
    
    if (event.target.localName === "rect") {
	
	//console.log("BROH", event.target.__data__.label, g.node())

	const newX = x + 20; // New node's X coordinate
        const newY = y + 20; // New node's Y coordinate
        const userInput = await openSearch('Create a new node with shift+enter or connect to an existing node');
        
        let label = userInput.label;
        let url = "";
        let imageUrl = "";
	
        if (isValidLink(label)) {
            label = await fetchPageTitle(label);
            url = label;
            // imageUrl = await getFavicon(label);
        }
	
        if (isYouTubeLink(userInput.label)) {
            imageUrl = getYouTubeThumbnail(userInput.label);
            url = userInput.label;
        }
        
        if (label) {
            if (!userInput.exists) {
                await createNodeAndLink(event.target.__data__.id, newX, newY, label, url, imageUrl);
            } else {
                await connectToNode(d.id, label);
            }
            drawNodesAndLinks(cur_trans);
        }
    }
}

// Attach the double-click event listener to the SVG canvas
svg.on("dblclick", handleDoubleClick);

// Apply the zoom behavior to the SVG element
svg.call(zoom).on("dblclick.zoom", null);



// Initial draw
drawGrid(d3.zoomIdentity);
drawNodesAndLinks(d3.zoomIdentity);

// Auto-save for inspector and code editor
const inputs = document.querySelectorAll("#inspector input, #code-editor textarea");
inputs.forEach(input => {
    input.addEventListener("input", async () => {
	console.log("input");
        const id = document.getElementById("nodeId").value;
        const label = document.getElementById("nodeLabel").value;
	const url = document.getElementById("nodeUrl").value;
	const imageUrl = document.getElementById("nodeImageUrl").value;
        const x = parseFloat(document.getElementById("nodeX").value);
        const y = parseFloat(document.getElementById("nodeY").value);
	const width = parseFloat(document.getElementById("nodeWidth").value);
	const height = parseFloat(document.getElementById("nodeHeight").value);
	const instance = parseFloat(document.getElementById("nodeInstance").value);
        const background = document.getElementById("nodeBackground").value;
	const type = document.getElementById("nodeType").value;
        const code = document.getElementById("nodeCode").value;
	
	console.log("UPDATING NODE", document.getElementById("nodeId"));
	if (type === "inherited") {
	    await updateInheritedNode(id, instance, x, y, width, height);
	} else {
	    await updateNodeProperties(id, label, url, imageUrl, x, y, width, height, instance, type, background, code);
	}

        // Update the node in the visualization
        const node = nodeLayer.selectAll("rect").filter(d => d.id === id)
              .attr("cx", x)
              .attr("cy", y)
              .attr("fill", background);

        const labelElement = nodeLayer.selectAll("text").filter(d => d.id === id)
              .attr("x", x + 10)
              .attr("y", y)
              .text(label);

        // Update the links connected to the node
        linkLayer.selectAll("line").filter(d => d.source === id || d.target === id)
            .attr("x1", d => nodes.find(n => n.id === d.source).x)
            .attr("y1", d => nodes.find(n => n.id === d.source).y)
            .attr("x2", d => nodes.find(n => n.id === d.target).x)
            .attr("y2", d => nodes.find(n => n.id === d.target).y);
    });
});
    </script>


<script>
    document.addEventListener('DOMContentLoaded', () => {
        const searchInput = document.getElementById('searchInput');
        const searchTitle = document.getElementById('searchTitle');
        const resultsContainer = document.getElementById('results');
        const spotlightSearch = document.getElementById('spotlightSearch');
        let currentIndex = -1;
        let currentResults = [];
        let resolveSearch;

        // Function to open the search interface and return a Promise
        window.openSearch = function(title) {
            return new Promise((resolve) => {
                console.log('Opening search interface'); // Debug log
                resolveSearch = resolve;
                searchTitle.textContent = title;
                spotlightSearch.style.display = 'block';
                searchInput.focus();
            });
        }

        // Function to close the search interface
        function closeSearch() {
            console.log('Closing search interface'); // Debug log
            spotlightSearch.style.display = 'none';
            currentIndex = -1;
            resultsContainer.innerHTML = '';
            searchInput.value = '';
        }

        // Add event listener to close search on pressing Escape
        document.addEventListener('keydown', (event) => {
            if (spotlightSearch.style.display === 'block') {
                if (event.key === 'Escape') {
                    closeSearch();
                    resolveSearch({ label: null, exists: false });
                } else if (event.key === 'ArrowDown') {
                    navigateResults(1);
                } else if (event.key === 'ArrowUp') {
                    navigateResults(-1);
                } else if (event.key === 'Enter') {
                    if (event.shiftKey) {
                        selectInput();
                    } else {
                        selectResult();
                    }
                }
            }
        });

        // Add event listener to handle input and search
        searchInput.addEventListener('input', (event) => {
            const query = event.target.value;
            if (query) {
                searchNeo4j(query);
            } else {
                resultsContainer.innerHTML = '';
            }
        });

        // Function to perform the search in Neo4j
        async function searchNeo4j(query) {
            //console.log('Searching Neo4j for:', query); // Debug log
            const fuzzyQuery = `(?i).*${query}.*`;
            const session = driver.session();
            try {
                const result = await session.run(
                    `MATCH (n) WHERE n.label =~ $query RETURN n LIMIT 10`,
                    { query: fuzzyQuery }
                );
                const nodes = result.records.flatMap(record => {
                    const node = record.get('n').properties;
                    return node.x_positions.map((x, index) => ({
                        id: node.id,
                        label: node.label,
                        x: node.x_positions[index],
                        y: node.y_positions[index],
			width: node.widths[index],
			height: node.heights[index],
                        instance: index
                    }));
                });
                currentResults = nodes;
                displayResults(nodes);
            } catch (error) {
                console.error(error);
            } finally {
                await session.close();
            }
        }

        // Function to display search results
        function displayResults(results) {
            //console.log('Displaying results:', results); // Debug log
            resultsContainer.innerHTML = '';
            results.forEach((result, index) => {
                const item = document.createElement('div');
                item.className = 'result-item';
                item.textContent = `${result.label} [${result.instance + 1}]`;
                item.dataset.index = index;
                item.addEventListener('click', () => {
                    selectResult(index);
                });
                resultsContainer.appendChild(item);
            });
        }

        // Function to navigate results with arrow keys
        function navigateResults(direction) {
            if (currentResults.length > 0) {
                currentIndex = (currentIndex + direction + currentResults.length) % currentResults.length;
                updateSelection();
            }
        }

        // Function to update the selected result
        function updateSelection() {
            const items = resultsContainer.getElementsByClassName('result-item');
            Array.from(items).forEach((item, index) => {
                if (index === currentIndex) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        // Function to select the current result
        function selectResult(index = currentIndex) {
            if (index >= 0 && index < currentResults.length) {
                const selectedItem = currentResults[index];
                closeSearch();
                resolveSearch({ label: selectedItem.label, exists: true, id: selectedItem.id, x: selectedItem.x, y: selectedItem.y, instance: selectedItem.instance });
            } else {
                // No results found, return current input
                selectInput();
            }
        }

        // Function to select the current input
        function selectInput() {
            const currentInput = searchInput.value;
            if (currentInput) {
                closeSearch();
                resolveSearch({ label: currentInput, exists: false });
            }
        }

        // Function to handle spotlight zoom
        window.spotlightZoom = async function() {
            //console.log('Invoking spotlight zoom'); // Debug log
            const userInput = await openSearch('Search for and zoom to a node on the canvas');
            console.log('User input:', userInput); // Debug log
            if (userInput.exists) {
                const nodeDetails = await fetchNodeById(userInput.id);
                console.log('Node details:', nodeDetails); // Debug log
                if (nodeDetails) {
                    const selectedPosition_x = nodeDetails.x_positions[userInput.instance];
                    const selectedPosition_y = nodeDetails.y_positions[userInput.instance];
                    const svg = d3.select('svg'); // Ensure you select the correct SVG element
                    const zoom = d3.zoom();
		    console.log("zooming")
                    svg.transition().call(zoom.translateTo, selectedPosition_x, selectedPosition_y);
                }
            }
        }

        // Add event listener for keydown to check for Ctrl + Space
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.code === 'Space') {
                event.preventDefault();  // Prevent default action if needed
                console.log('Ctrl + Space pressed'); // Debug log
                window.spotlightZoom();
            }
        });
    });

    </script>




				


    
    
    
</body>
</html>

